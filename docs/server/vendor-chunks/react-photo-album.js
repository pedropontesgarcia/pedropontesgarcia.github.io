"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-photo-album";
exports.ids = ["vendor-chunks/react-photo-album"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-photo-album/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-photo-album/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhotoAlbum: () => (/* binding */ PhotoAlbum),\n/* harmony export */   \"default\": () => (/* binding */ PhotoAlbum),\n/* harmony export */   unstable_computeColumnsLayout: () => (/* binding */ computeColumnsLayout),\n/* harmony export */   unstable_computeMasonryLayout: () => (/* binding */ computeMasonryLayout),\n/* harmony export */   unstable_computeRowsLayout: () => (/* binding */ computeRowsLayout)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ PhotoAlbum,default,unstable_computeColumnsLayout,unstable_computeMasonryLayout,unstable_computeRowsLayout auto */ \nfunction ratio({ width, height }) {\n    return width / height;\n}\nfunction round(value, decimals = 0) {\n    const factor = 10 ** decimals;\n    return Math.round((value + Number.EPSILON) * factor) / factor;\n}\nfunction rankingFunctionComparator(rank) {\n    return (a, b)=>rank(b) - rank(a);\n}\nclass MinHeap {\n    constructor(comparator){\n        this.comparator = comparator;\n        this.heap = [];\n        this.n = 0;\n    }\n    greater(i, j) {\n        return this.comparator(this.heap[i], this.heap[j]) < 0;\n    }\n    swap(i, j) {\n        const temp = this.heap[i];\n        this.heap[i] = this.heap[j];\n        this.heap[j] = temp;\n    }\n    swim(i) {\n        let k = i;\n        let k2 = Math.floor(k / 2);\n        while(k > 1 && this.greater(k2, k)){\n            this.swap(k2, k);\n            k = k2;\n            k2 = Math.floor(k / 2);\n        }\n    }\n    sink(i) {\n        let k = i;\n        let k2 = k * 2;\n        while(k2 <= this.n){\n            if (k2 < this.n && this.greater(k2, k2 + 1)) k2 += 1;\n            if (!this.greater(k, k2)) break;\n            this.swap(k, k2);\n            k = k2;\n            k2 = k * 2;\n        }\n    }\n    push(element) {\n        this.n += 1;\n        this.heap[this.n] = element;\n        this.swim(this.n);\n    }\n    pop() {\n        if (this.n === 0) return void 0;\n        this.swap(1, this.n);\n        this.n -= 1;\n        const max = this.heap.pop();\n        this.sink(1);\n        return max;\n    }\n    size() {\n        return this.n;\n    }\n}\nfunction buildPrecedentsMap(graph, startNode, endNode) {\n    const precedentsMap = /* @__PURE__ */ new Map();\n    const visited = /* @__PURE__ */ new Set();\n    const storedShortestPaths = /* @__PURE__ */ new Map();\n    storedShortestPaths.set(startNode, 0);\n    const queue = new MinHeap(rankingFunctionComparator((el)=>el.weight));\n    queue.push({\n        id: startNode,\n        weight: 0\n    });\n    while(queue.size() > 0){\n        const { id, weight } = queue.pop();\n        if (!visited.has(id)) {\n            const neighboringNodes = graph(id);\n            visited.add(id);\n            neighboringNodes.forEach((neighborWeight, neighbor)=>{\n                const newWeight = weight + neighborWeight;\n                const currentId = precedentsMap.get(neighbor);\n                const currentWeight = storedShortestPaths.get(neighbor);\n                if (currentWeight === void 0 || currentWeight > newWeight && (currentWeight / newWeight > 1.005 || currentId !== void 0 && currentId < id)) {\n                    storedShortestPaths.set(neighbor, newWeight);\n                    queue.push({\n                        id: neighbor,\n                        weight: newWeight\n                    });\n                    precedentsMap.set(neighbor, id);\n                }\n            });\n        }\n    }\n    return storedShortestPaths.has(endNode) ? precedentsMap : void 0;\n}\nfunction getPathFromPrecedentsMap(precedentsMap, endNode) {\n    const nodes = [];\n    for(let node = endNode; node !== void 0; node = precedentsMap.get(node)){\n        nodes.push(node);\n    }\n    return nodes.reverse();\n}\nfunction findShortestPath(graph, startNode, endNode) {\n    const precedentsMap = buildPrecedentsMap(graph, startNode, endNode);\n    return precedentsMap ? getPathFromPrecedentsMap(precedentsMap, endNode) : void 0;\n}\nfunction findIdealNodeSearch({ photos, targetRowHeight, containerWidth }) {\n    const minRatio = photos.reduce((acc, photo)=>Math.min(ratio(photo), acc), Number.MAX_VALUE);\n    return round(containerWidth / targetRowHeight / minRatio) + 2;\n}\nfunction getCommonHeight(row, containerWidth, spacing, padding) {\n    const rowWidth = containerWidth - (row.length - 1) * spacing - 2 * padding * row.length;\n    const totalAspectRatio = row.reduce((acc, photo)=>acc + ratio(photo), 0);\n    return rowWidth / totalAspectRatio;\n}\nfunction cost(photos, i, j, width, targetRowHeight, spacing, padding) {\n    const row = photos.slice(i, j);\n    const commonHeight = getCommonHeight(row, width, spacing, padding);\n    return commonHeight > 0 ? (commonHeight - targetRowHeight) ** 2 * row.length : void 0;\n}\nfunction makeGetRowNeighbors({ photos, layoutOptions, targetRowHeight, limitNodeSearch, rowConstraints }) {\n    return (node)=>{\n        var _a, _b;\n        const { containerWidth, spacing, padding } = layoutOptions;\n        const results = /* @__PURE__ */ new Map();\n        results.set(node, 0);\n        const startOffset = (_a = rowConstraints == null ? void 0 : rowConstraints.minPhotos) != null ? _a : 1;\n        const endOffset = Math.min(limitNodeSearch, (_b = rowConstraints == null ? void 0 : rowConstraints.maxPhotos) != null ? _b : Infinity);\n        for(let i = node + startOffset; i < photos.length + 1; i += 1){\n            if (i - node > endOffset) break;\n            const currentCost = cost(photos, node, i, containerWidth, targetRowHeight, spacing, padding);\n            if (currentCost === void 0) break;\n            results.set(i, currentCost);\n        }\n        return results;\n    };\n}\nfunction computeRowsLayout({ photos, layoutOptions }) {\n    const { spacing, padding, containerWidth, targetRowHeight, rowConstraints } = layoutOptions;\n    const limitNodeSearch = findIdealNodeSearch({\n        photos,\n        containerWidth,\n        targetRowHeight\n    });\n    const getNeighbors = makeGetRowNeighbors({\n        photos,\n        layoutOptions,\n        targetRowHeight,\n        limitNodeSearch,\n        rowConstraints\n    });\n    const path = findShortestPath(getNeighbors, 0, photos.length);\n    if (path === void 0) return void 0;\n    const layout = [];\n    for(let i = 1; i < path.length; i += 1){\n        const row = photos.map((photo, index)=>({\n                photo,\n                index\n            })).slice(path[i - 1], path[i]);\n        const height = getCommonHeight(row.map(({ photo })=>photo), containerWidth, spacing, padding);\n        layout.push(row.map(({ photo, index }, photoIndex)=>({\n                photo,\n                layout: {\n                    height,\n                    width: height * ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: row.length\n                }\n            })));\n    }\n    return layout;\n}\nfunction clsx(...classes) {\n    return [\n        ...classes\n    ].filter((cls)=>Boolean(cls)).join(\" \");\n}\nfunction calcWidth(base, { width, photosCount }, { spacing, padding, containerWidth }) {\n    const gaps = spacing * (photosCount - 1) + 2 * padding * photosCount;\n    return `calc((${base} - ${gaps}px) / ${round((containerWidth - gaps) / width, 5)})`;\n}\nfunction cssPhotoWidth(layout, layoutOptions) {\n    return layoutOptions.layout !== \"rows\" ? `calc(100% - ${2 * layoutOptions.padding}px)` : calcWidth(\"100%\", layout, layoutOptions);\n}\nfunction calculateSizesValue(size, layout, layoutOptions) {\n    var _a, _b;\n    return calcWidth((_b = (_a = size.match(/^\\s*calc\\((.*)\\)\\s*$/)) == null ? void 0 : _a[1]) != null ? _b : size, layout, layoutOptions);\n}\nfunction srcSetAndSizes(photo, layout, layoutOptions) {\n    let srcSet;\n    let sizes;\n    const images = photo.srcSet || photo.images;\n    if (images && images.length > 0) {\n        srcSet = images.concat(!images.find(({ width })=>width === photo.width) ? [\n            {\n                src: photo.src,\n                width: photo.width,\n                height: photo.height\n            }\n        ] : []).sort((first, second)=>first.width - second.width).map((image)=>`${image.src} ${image.width}w`).join(\", \");\n    }\n    if (layoutOptions.sizes) {\n        sizes = (layoutOptions.sizes.sizes || []).map(({ viewport, size })=>`${viewport} ${calculateSizesValue(size, layout, layoutOptions)}`).concat(calculateSizesValue(layoutOptions.sizes.size, layout, layoutOptions)).join(\", \");\n    } else if (srcSet) {\n        sizes = `${Math.ceil(layout.width / layoutOptions.containerWidth * 100)}vw`;\n    }\n    return {\n        srcSet,\n        sizes\n    };\n}\nfunction PhotoRenderer(props) {\n    var _a, _b;\n    const { photo, layout, layoutOptions, imageProps: { style, className, ...restImageProps } = {}, renderPhoto } = props;\n    const { onClick } = layoutOptions;\n    const imageStyle = {\n        display: \"block\",\n        boxSizing: \"content-box\",\n        width: cssPhotoWidth(layout, layoutOptions),\n        height: \"auto\",\n        aspectRatio: `${photo.width} / ${photo.height}`,\n        ...layoutOptions.padding ? {\n            padding: `${layoutOptions.padding}px`\n        } : null,\n        ...(layoutOptions.layout === \"columns\" || layoutOptions.layout === \"masonry\") && layout.photoIndex < layout.photosCount - 1 ? {\n            marginBottom: `${layoutOptions.spacing}px`\n        } : null,\n        ...onClick ? {\n            cursor: \"pointer\"\n        } : null,\n        ...style\n    };\n    const handleClick = onClick ? (event)=>{\n        onClick({\n            event,\n            photo,\n            index: layout.index\n        });\n    } : void 0;\n    const imageProps = {\n        src: photo.src,\n        alt: (_a = photo.alt) != null ? _a : \"\",\n        title: photo.title,\n        onClick: handleClick,\n        style: imageStyle,\n        className: clsx(\"react-photo-album--photo\", className),\n        loading: \"lazy\",\n        decoding: \"async\",\n        ...srcSetAndSizes(photo, layout, layoutOptions),\n        ...restImageProps\n    };\n    const renderDefaultPhoto = (options)=>{\n        const { src, alt, srcSet, sizes, style: unwrappedStyle, ...rest } = imageProps;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n            alt,\n            ...srcSet ? {\n                srcSet,\n                sizes\n            } : null,\n            src,\n            style: (options == null ? void 0 : options.wrapped) ? {\n                display: \"block\",\n                width: \"100%\",\n                height: \"100%\"\n            } : unwrappedStyle,\n            ...rest\n        });\n    };\n    const wrapperStyle = (({ display, boxSizing, width, aspectRatio, padding, marginBottom, cursor })=>({\n            display,\n            boxSizing,\n            width,\n            aspectRatio,\n            padding,\n            marginBottom,\n            cursor\n        }))(imageStyle);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (_b = renderPhoto == null ? void 0 : renderPhoto({\n        photo,\n        layout,\n        layoutOptions,\n        imageProps,\n        renderDefaultPhoto,\n        wrapperStyle\n    })) != null ? _b : renderDefaultPhoto());\n}\nfunction defaultRenderRowContainer({ rowContainerProps, children }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...rowContainerProps\n    }, children);\n}\nfunction RowContainerRenderer(props) {\n    const { layoutOptions, rowIndex, rowsCount, renderRowContainer, rowContainerProps: { style, className, ...restRowContainerProps } = {}, children } = props;\n    const rowContainerProps = {\n        className: clsx(\"react-photo-album--row\", className),\n        style: {\n            display: \"flex\",\n            flexDirection: \"row\",\n            flexWrap: \"nowrap\",\n            alignItems: \"flex-start\",\n            justifyContent: \"space-between\",\n            ...rowIndex < rowsCount - 1 ? {\n                marginBottom: `${layoutOptions.spacing}px`\n            } : null,\n            ...style\n        },\n        ...restRowContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderRowContainer != null ? renderRowContainer : defaultRenderRowContainer)({\n        layoutOptions,\n        rowIndex,\n        rowsCount,\n        rowContainerProps,\n        children\n    }));\n}\nfunction RowsLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderRowContainer, componentsProps: { imageProps, rowContainerProps } } = props;\n    const rowsLayout = computeRowsLayout({\n        photos,\n        layoutOptions\n    });\n    if (!rowsLayout) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, rowsLayout.map((row, rowIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowContainerRenderer, {\n            key: `row-${rowIndex}`,\n            layoutOptions,\n            rowIndex,\n            rowsCount: rowsLayout.length,\n            renderRowContainer,\n            rowContainerProps\n        }, row.map(({ photo, layout })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            })))));\n}\nfunction computeShortestPath(graph, pathLength, startNode, endNode) {\n    const matrix = /* @__PURE__ */ new Map();\n    const queue = /* @__PURE__ */ new Set();\n    queue.add(startNode);\n    for(let length = 0; length < pathLength; length += 1){\n        const currentQueue = [\n            ...queue.keys()\n        ];\n        queue.clear();\n        currentQueue.forEach((node)=>{\n            const accumulatedWeight = length > 0 ? matrix.get(node)[length].weight : 0;\n            graph(node).forEach(({ neighbor, weight })=>{\n                let paths = matrix.get(neighbor);\n                if (!paths) {\n                    paths = [];\n                    matrix.set(neighbor, paths);\n                }\n                const newWeight = accumulatedWeight + weight;\n                const nextPath = paths[length + 1];\n                if (!nextPath || nextPath.weight > newWeight && (nextPath.weight / newWeight > 1.0001 || node < nextPath.node)) {\n                    paths[length + 1] = {\n                        node,\n                        weight: newWeight\n                    };\n                }\n                if (length < pathLength - 1 && neighbor !== endNode) {\n                    queue.add(neighbor);\n                }\n            });\n        });\n    }\n    return matrix;\n}\nfunction reconstructShortestPath(matrix, pathLength, endNode) {\n    const path = [\n        endNode\n    ];\n    for(let node = endNode, length = pathLength; length > 0; length -= 1){\n        node = matrix.get(node)[length].node;\n        path.push(node);\n    }\n    return path.reverse();\n}\nfunction findShortestPathLengthN(graph, pathLength, startNode, endNode) {\n    return reconstructShortestPath(computeShortestPath(graph, pathLength, startNode, endNode), pathLength, endNode);\n}\nfunction makeGetColumnNeighbors({ photos, spacing, padding, targetColumnWidth, targetColumnHeight }) {\n    return (node)=>{\n        const results = [];\n        const cutOffHeight = targetColumnHeight * 1.5;\n        let height = targetColumnWidth / ratio(photos[node]) + 2 * padding;\n        for(let i = node + 1; i < photos.length + 1; i += 1){\n            results.push({\n                neighbor: i,\n                weight: (targetColumnHeight - height) ** 2\n            });\n            if (height > cutOffHeight || i === photos.length) {\n                break;\n            }\n            height += targetColumnWidth / ratio(photos[i]) + spacing + 2 * padding;\n        }\n        return results;\n    };\n}\nfunction buildColumnsModel({ path, photos, containerWidth, columnsGaps, columnsRatios, spacing, padding }) {\n    const columnsModel = [];\n    const totalRatio = columnsRatios.reduce((total, columnRatio)=>total + columnRatio, 0);\n    for(let i = 0; i < path.length - 1; i += 1){\n        const column = photos.map((photo, index)=>({\n                photo,\n                index\n            })).slice(path[i], path[i + 1]);\n        const totalAdjustedGaps = columnsRatios.reduce((total, columnRatio, index)=>total + (columnsGaps[i] - columnsGaps[index]) * columnRatio, 0);\n        const columnWidth = (containerWidth - (path.length - 2) * spacing - 2 * (path.length - 1) * padding - totalAdjustedGaps) * columnsRatios[i] / totalRatio;\n        columnsModel.push(column.map(({ photo, index }, photoIndex)=>({\n                photo,\n                layout: {\n                    width: columnWidth,\n                    height: columnWidth / ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: column.length\n                }\n            })));\n    }\n    return columnsModel;\n}\nfunction computeColumnsModel({ photos, layoutOptions, targetColumnWidth }) {\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const columnsGaps = [];\n    const columnsRatios = [];\n    if (photos.length <= columns) {\n        const averageRatio = photos.length > 0 ? photos.reduce((acc, photo)=>acc + ratio(photo), 0) / photos.length : 1;\n        for(let i = 0; i < columns; i += 1){\n            columnsGaps[i] = 2 * padding;\n            columnsRatios[i] = i < photos.length ? ratio(photos[i]) : averageRatio;\n        }\n        const columnsModel2 = buildColumnsModel({\n            path: Array.from({\n                length: columns + 1\n            }).map((_, index)=>Math.min(index, photos.length)),\n            photos,\n            columnsRatios,\n            columnsGaps,\n            containerWidth,\n            spacing,\n            padding\n        });\n        return {\n            columnsGaps,\n            columnsRatios,\n            columnsModel: columnsModel2\n        };\n    }\n    const targetColumnHeight = (photos.reduce((acc, photo)=>acc + targetColumnWidth / ratio(photo), 0) + spacing * (photos.length - columns) + 2 * padding * photos.length) / columns;\n    const getNeighbors = makeGetColumnNeighbors({\n        photos,\n        targetColumnWidth,\n        targetColumnHeight,\n        spacing,\n        padding\n    });\n    const path = findShortestPathLengthN(getNeighbors, columns, 0, photos.length);\n    for(let i = 0; i < path.length - 1; i += 1){\n        const column = photos.slice(path[i], path[i + 1]);\n        columnsGaps[i] = spacing * (column.length - 1) + 2 * padding * column.length;\n        columnsRatios[i] = 1 / column.reduce((acc, photo)=>acc + 1 / ratio(photo), 0);\n    }\n    const columnsModel = buildColumnsModel({\n        path,\n        photos,\n        columnsRatios,\n        columnsGaps,\n        containerWidth,\n        spacing,\n        padding\n    });\n    return {\n        columnsGaps,\n        columnsRatios,\n        columnsModel\n    };\n}\nfunction computeLayout(props) {\n    const { photos, layoutOptions } = props;\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const targetColumnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n    const { columnsGaps, columnsRatios, columnsModel } = computeColumnsModel({\n        photos,\n        layoutOptions,\n        targetColumnWidth\n    });\n    if (columnsModel.findIndex((columnModel)=>columnModel.findIndex(({ layout: { width, height } })=>width < 0 || height < 0) >= 0) >= 0) {\n        if (columns > 1) {\n            return computeLayout({\n                photos,\n                layoutOptions: {\n                    ...layoutOptions,\n                    columns: columns - 1\n                }\n            });\n        }\n        return void 0;\n    }\n    return {\n        columnsModel,\n        columnsGaps,\n        columnsRatios\n    };\n}\nfunction computeColumnsLayout({ photos, layoutOptions }) {\n    return computeLayout({\n        photos,\n        layoutOptions\n    });\n}\nfunction defaultRenderColumnContainer({ columnContainerProps, children }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...columnContainerProps\n    }, children);\n}\nfunction cssColumnWidth(props) {\n    const { layoutOptions, columnIndex, columnsCount, columnsGaps, columnsRatios } = props;\n    const { layout, spacing, padding } = layoutOptions;\n    if (layout === \"masonry\" || !columnsGaps || !columnsRatios) {\n        return `calc((100% - ${spacing * (columnsCount - 1)}px) / ${columnsCount})`;\n    }\n    const totalRatio = columnsRatios.reduce((acc, ratio2)=>acc + ratio2, 0);\n    const totalAdjustedGaps = columnsRatios.reduce((acc, ratio2, index)=>acc + (columnsGaps[columnIndex] - columnsGaps[index]) * ratio2, 0);\n    return `calc((100% - ${round((columnsCount - 1) * spacing + 2 * columnsCount * padding + totalAdjustedGaps, 3)}px) * ${round(columnsRatios[columnIndex] / totalRatio, 5)} + ${2 * padding}px)`;\n}\nfunction ColumnContainerRenderer(props) {\n    const { layoutOptions, renderColumnContainer, children, columnContainerProps: { style, className, ...restColumnContainerProps } = {}, ...rest } = props;\n    const columnContainerProps = {\n        className: clsx(\"react-photo-album--column\", className),\n        style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            flexWrap: \"nowrap\",\n            alignItems: \"flex-start\",\n            width: cssColumnWidth(props),\n            justifyContent: layoutOptions.layout === \"columns\" ? \"space-between\" : \"flex-start\",\n            ...style\n        },\n        ...restColumnContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderColumnContainer != null ? renderColumnContainer : defaultRenderColumnContainer)({\n        layoutOptions,\n        columnContainerProps,\n        children,\n        ...rest\n    }));\n}\nfunction ColumnsLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderColumnContainer, componentsProps: { imageProps, columnContainerProps } } = props;\n    const columnsLayout = computeColumnsLayout({\n        photos,\n        layoutOptions\n    });\n    if (!columnsLayout) return null;\n    const { columnsModel, columnsRatios, columnsGaps } = columnsLayout;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, columnsModel.map((column, columnIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnContainerRenderer, {\n            key: `column-${columnIndex}`,\n            layoutOptions,\n            columnIndex,\n            columnsCount: columnsModel.length,\n            columnsGaps,\n            columnsRatios,\n            renderColumnContainer,\n            columnContainerProps\n        }, column.map(({ photo, layout })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            })))));\n}\nfunction computeMasonryLayout(props) {\n    const { photos, layoutOptions } = props;\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const columnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n    if (columnWidth <= 0) {\n        return columns > 1 ? computeMasonryLayout({\n            ...props,\n            layoutOptions: {\n                ...layoutOptions,\n                columns: columns - 1\n            }\n        }) : void 0;\n    }\n    const columnsCurrentTopPositions = [];\n    for(let i = 0; i < columns; i += 1){\n        columnsCurrentTopPositions[i] = 0;\n    }\n    const columnsModel = photos.reduce((model, photo, index)=>{\n        const shortestColumn = columnsCurrentTopPositions.reduce((currentShortestColumn, item, i)=>item < columnsCurrentTopPositions[currentShortestColumn] - 1 ? i : currentShortestColumn, 0);\n        columnsCurrentTopPositions[shortestColumn] = columnsCurrentTopPositions[shortestColumn] + columnWidth / ratio(photo) + spacing + 2 * padding;\n        model[shortestColumn].push({\n            photo,\n            index\n        });\n        return model;\n    }, Array.from({\n        length: columns\n    }).map(()=>[]));\n    return columnsModel.map((column)=>column.map(({ photo, index }, photoIndex)=>({\n                photo,\n                layout: {\n                    width: columnWidth,\n                    height: columnWidth / ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: column.length\n                }\n            })));\n}\nfunction MasonryLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderColumnContainer, componentsProps: { imageProps, columnContainerProps } } = props;\n    const masonryLayout = computeMasonryLayout({\n        photos,\n        layoutOptions\n    });\n    if (!masonryLayout) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, masonryLayout.map((column, columnIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnContainerRenderer, {\n            key: `masonry-column-${columnIndex}`,\n            layoutOptions,\n            columnsCount: masonryLayout.length,\n            columnIndex,\n            renderColumnContainer,\n            columnContainerProps\n        }, column.map(({ photo, layout })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            })))));\n}\nfunction defaultRenderContainer({ containerProps, children, containerRef }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: containerRef,\n        ...containerProps\n    }, children);\n}\nfunction ContainerRenderer(props) {\n    const { layout, renderContainer, children, containerRef, containerProps: { style, className, ...restContainerProps } = {} } = props;\n    const containerProps = {\n        className: clsx(\"react-photo-album\", `react-photo-album--${layout}`, className),\n        style: {\n            display: \"flex\",\n            flexWrap: \"nowrap\",\n            justifyContent: \"space-between\",\n            flexDirection: layout === \"rows\" ? \"column\" : \"row\",\n            ...style\n        },\n        ...restContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderContainer != null ? renderContainer : defaultRenderContainer)({\n        containerProps,\n        containerRef,\n        layout,\n        children\n    }));\n}\nfunction useArray(array) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(array);\n    if (!array || !ref.current || array.join() !== ref.current.join()) {\n        ref.current = array;\n    }\n    return ref.current;\n}\nfunction containerWidthReducer(state, { newContainerWidth, newScrollbarWidth }) {\n    const { containerWidth, scrollbarWidth } = state;\n    if (containerWidth !== void 0 && scrollbarWidth !== void 0 && newContainerWidth !== void 0 && newScrollbarWidth !== void 0 && newContainerWidth > containerWidth && newContainerWidth - containerWidth <= 20 && newScrollbarWidth < scrollbarWidth) {\n        return {\n            containerWidth,\n            scrollbarWidth: newScrollbarWidth\n        };\n    }\n    return containerWidth !== newContainerWidth || scrollbarWidth !== newScrollbarWidth ? {\n        containerWidth: newContainerWidth,\n        scrollbarWidth: newScrollbarWidth\n    } : state;\n}\nfunction resolveContainerWidth(el, breakpoints2) {\n    let width = el == null ? void 0 : el.clientWidth;\n    if (width !== void 0 && breakpoints2 && breakpoints2.length > 0) {\n        const sorted = [\n            ...breakpoints2.filter((x)=>x > 0)\n        ].sort((a, b)=>b - a);\n        sorted.push(Math.floor(sorted[sorted.length - 1] / 2));\n        const threshold = width;\n        width = sorted.find((breakpoint, index)=>breakpoint <= threshold || index === sorted.length - 1);\n    }\n    return width;\n}\nfunction useContainerWidth(breakpoints2, defaultContainerWidth) {\n    const [{ containerWidth }, dispatch] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(containerWidthReducer, {\n        containerWidth: defaultContainerWidth\n    });\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const observerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const containerRef = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        var _a;\n        (_a = observerRef.current) == null ? void 0 : _a.disconnect();\n        observerRef.current = void 0;\n        ref.current = node;\n        const updateWidth = ()=>dispatch({\n                newContainerWidth: resolveContainerWidth(ref.current, breakpoints2),\n                newScrollbarWidth: window.innerWidth - document.documentElement.clientWidth\n            });\n        updateWidth();\n        if (node && typeof ResizeObserver !== \"undefined\") {\n            observerRef.current = new ResizeObserver(updateWidth);\n            observerRef.current.observe(node);\n        }\n    }, [\n        breakpoints2\n    ]);\n    return {\n        containerRef,\n        containerWidth\n    };\n}\nconst breakpoints = Object.freeze([\n    1200,\n    600,\n    300,\n    0\n]);\nfunction unwrap(value, arg) {\n    return typeof value === \"function\" ? value(arg) : value;\n}\nfunction unwrapParameter(value, containerWidth) {\n    return typeof value !== \"undefined\" ? unwrap(value, containerWidth) : void 0;\n}\nfunction selectResponsiveValue(values, containerWidth) {\n    const index = breakpoints.findIndex((breakpoint)=>breakpoint <= containerWidth);\n    return unwrap(values[index >= 0 ? index : 0], containerWidth);\n}\nfunction resolveResponsiveParameter(parameter, containerWidth, values, minValue = 0) {\n    const value = unwrapParameter(parameter, containerWidth);\n    return Math.round(Math.max(value === void 0 ? selectResponsiveValue(values, containerWidth) : value, minValue));\n}\nfunction resolveLayoutOptions({ layout, onClick, containerWidth, targetRowHeight, rowConstraints, columns, spacing, padding, sizes }) {\n    return {\n        layout,\n        onClick,\n        containerWidth,\n        columns: resolveResponsiveParameter(columns, containerWidth, [\n            5,\n            4,\n            3,\n            2\n        ], 1),\n        spacing: resolveResponsiveParameter(spacing, containerWidth, [\n            20,\n            15,\n            10,\n            5\n        ]),\n        padding: resolveResponsiveParameter(padding, containerWidth, [\n            0,\n            0,\n            0,\n            0,\n            0\n        ]),\n        targetRowHeight: resolveResponsiveParameter(targetRowHeight, containerWidth, [\n            (w)=>w / 5,\n            (w)=>w / 4,\n            (w)=>w / 3,\n            (w)=>w / 2\n        ]),\n        rowConstraints: unwrapParameter(rowConstraints, containerWidth),\n        sizes\n    };\n}\nfunction resolveComponentsProps(props, containerWidth, layoutOptions) {\n    const { photos, componentsProps: componentsPropsProp } = props;\n    const componentsProps = unwrap(componentsPropsProp, containerWidth) || {};\n    if (layoutOptions) {\n        const { layout, spacing, padding, rowConstraints } = layoutOptions;\n        if (layout === \"rows\") {\n            const { singleRowMaxHeight } = rowConstraints || {};\n            if (singleRowMaxHeight) {\n                const maxWidth = Math.floor(photos.reduce((acc, { width, height })=>acc + width / height * singleRowMaxHeight - 2 * padding, padding * photos.length * 2 + spacing * (photos.length - 1)));\n                if (maxWidth > 0) {\n                    componentsProps.containerProps = componentsProps.containerProps || {};\n                    componentsProps.containerProps.style = {\n                        maxWidth,\n                        ...componentsProps.containerProps.style\n                    };\n                }\n            }\n        }\n    }\n    return componentsProps;\n}\nfunction renderLayout(props, componentsProps, layoutOptions) {\n    const { photos, layout, renderPhoto, renderRowContainer, renderColumnContainer } = props;\n    const commonLayoutProps = {\n        photos,\n        renderPhoto,\n        componentsProps\n    };\n    if (layout === \"rows\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowsLayout, {\n            layoutOptions,\n            renderRowContainer,\n            ...commonLayoutProps\n        });\n    }\n    if (layout === \"columns\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnsLayout, {\n            layoutOptions,\n            renderColumnContainer,\n            ...commonLayoutProps\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MasonryLayout, {\n        layoutOptions,\n        renderColumnContainer,\n        ...commonLayoutProps\n    });\n}\nfunction PhotoAlbum(props) {\n    const { photos, layout, renderContainer, defaultContainerWidth, breakpoints: breakpoints2 } = props;\n    const { containerRef, containerWidth } = useContainerWidth(useArray(breakpoints2), defaultContainerWidth);\n    if (!layout || ![\n        \"rows\",\n        \"columns\",\n        \"masonry\"\n    ].includes(layout) || !Array.isArray(photos)) return null;\n    const layoutOptions = containerWidth ? resolveLayoutOptions({\n        containerWidth,\n        ...props\n    }) : void 0;\n    const componentsProps = resolveComponentsProps(props, containerWidth, layoutOptions);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContainerRenderer, {\n        layout,\n        containerRef,\n        renderContainer,\n        containerProps: componentsProps.containerProps\n    }, layoutOptions && renderLayout(props, componentsProps, layoutOptions));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGhvdG8tYWxidW0vZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OytKQUMrQjtBQUMvQixTQUFTQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQzlCLE9BQU9ELFFBQVFDO0FBQ2pCO0FBQ0EsU0FBU0MsTUFBTUMsS0FBSyxFQUFFQyxXQUFXLENBQUM7SUFDaEMsTUFBTUMsU0FBUyxNQUFNRDtJQUNyQixPQUFPRSxLQUFLSixLQUFLLENBQUMsQ0FBQ0MsUUFBUUksT0FBT0MsT0FBTyxJQUFJSCxVQUFVQTtBQUN6RDtBQUNBLFNBQVNJLDBCQUEwQkMsSUFBSTtJQUNyQyxPQUFPLENBQUNDLEdBQUdDLElBQU1GLEtBQUtFLEtBQUtGLEtBQUtDO0FBQ2xDO0FBQ0EsTUFBTUU7SUFDSkMsWUFBWUMsVUFBVSxDQUFFO1FBQ3RCLElBQUksQ0FBQ0EsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLElBQUksR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDQyxDQUFDLEdBQUc7SUFDWDtJQUNBQyxRQUFRQyxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDTCxVQUFVLENBQUMsSUFBSSxDQUFDQyxJQUFJLENBQUNHLEVBQUUsRUFBRSxJQUFJLENBQUNILElBQUksQ0FBQ0ksRUFBRSxJQUFJO0lBQ3ZEO0lBQ0FDLEtBQUtGLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ1QsTUFBTUUsT0FBTyxJQUFJLENBQUNOLElBQUksQ0FBQ0csRUFBRTtRQUN6QixJQUFJLENBQUNILElBQUksQ0FBQ0csRUFBRSxHQUFHLElBQUksQ0FBQ0gsSUFBSSxDQUFDSSxFQUFFO1FBQzNCLElBQUksQ0FBQ0osSUFBSSxDQUFDSSxFQUFFLEdBQUdFO0lBQ2pCO0lBQ0FDLEtBQUtKLENBQUMsRUFBRTtRQUNOLElBQUlLLElBQUlMO1FBQ1IsSUFBSU0sS0FBS25CLEtBQUtvQixLQUFLLENBQUNGLElB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STtRQUNBLEdBQUdtRSxpQkFBaUI7SUFDdEI7QUFFSjtBQUNBLFNBQVNDLFdBQVcxSixLQUFLO0lBQ3ZCLE1BQU0sRUFBRWxFLE1BQU0sRUFBRW1DLE1BQU0sRUFBRXNJLGVBQWUsRUFBRW1CLHFCQUFxQixFQUFFYSxhQUFhcEIsWUFBWSxFQUFFLEdBQUduSDtJQUM5RixNQUFNLEVBQUVvRyxZQUFZLEVBQUVwSyxjQUFjLEVBQUUsR0FBR3lMLGtCQUFrQmhCLFNBQVNVLGVBQWVPO0lBQ25GLElBQUksQ0FBQ3pKLFVBQVUsQ0FBQztRQUFDO1FBQVE7UUFBVztLQUFVLENBQUMwTCxRQUFRLENBQUMxTCxXQUFXLENBQUN1RyxNQUFNb0YsT0FBTyxDQUFDOU4sU0FDaEYsT0FBTztJQUNULE1BQU1vQixnQkFBZ0JsQixpQkFBaUJrTixxQkFBcUI7UUFBRWxOO1FBQWdCLEdBQUdnRSxLQUFLO0lBQUMsS0FBSyxLQUFLO0lBQ2pHLE1BQU13QyxrQkFBa0I0Ryx1QkFBdUJwSixPQUFPaEUsZ0JBQWdCa0I7SUFDdEUscUJBQU9yRixnREFBbUIsQ0FDeEJ5TyxtQkFDQTtRQUNFckk7UUFDQW1JO1FBQ0FHO1FBQ0FKLGdCQUFnQjNELGdCQUFnQjJELGNBQWM7SUFDaEQsR0FDQWpKLGlCQUFpQnNNLGFBQWF4SixPQUFPd0MsaUJBQWlCdEY7QUFFMUQ7QUFPRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BlZHJvcy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBob3RvLWFsYnVtL2Rpc3QvaW5kZXgubWpzP2I0NjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHJhdGlvKHsgd2lkdGgsIGhlaWdodCB9KSB7XG4gIHJldHVybiB3aWR0aCAvIGhlaWdodDtcbn1cbmZ1bmN0aW9uIHJvdW5kKHZhbHVlLCBkZWNpbWFscyA9IDApIHtcbiAgY29uc3QgZmFjdG9yID0gMTAgKiogZGVjaW1hbHM7XG4gIHJldHVybiBNYXRoLnJvdW5kKCh2YWx1ZSArIE51bWJlci5FUFNJTE9OKSAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5mdW5jdGlvbiByYW5raW5nRnVuY3Rpb25Db21wYXJhdG9yKHJhbmspIHtcbiAgcmV0dXJuIChhLCBiKSA9PiByYW5rKGIpIC0gcmFuayhhKTtcbn1cbmNsYXNzIE1pbkhlYXAge1xuICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yKSB7XG4gICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICB0aGlzLmhlYXAgPSBbXTtcbiAgICB0aGlzLm4gPSAwO1xuICB9XG4gIGdyZWF0ZXIoaSwgaikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmF0b3IodGhpcy5oZWFwW2ldLCB0aGlzLmhlYXBbal0pIDwgMDtcbiAgfVxuICBzd2FwKGksIGopIHtcbiAgICBjb25zdCB0ZW1wID0gdGhpcy5oZWFwW2ldO1xuICAgIHRoaXMuaGVhcFtpXSA9IHRoaXMuaGVhcFtqXTtcbiAgICB0aGlzLmhlYXBbal0gPSB0ZW1wO1xuICB9XG4gIHN3aW0oaSkge1xuICAgIGxldCBrID0gaTtcbiAgICBsZXQgazIgPSBNYXRoLmZsb29yKGsgLyAyKTtcbiAgICB3aGlsZSAoayA+IDEgJiYgdGhpcy5ncmVhdGVyKGsyLCBrKSkge1xuICAgICAgdGhpcy5zd2FwKGsyLCBrKTtcbiAgICAgIGsgPSBrMjtcbiAgICAgIGsyID0gTWF0aC5mbG9vcihrIC8gMik7XG4gICAgfVxuICB9XG4gIHNpbmsoaSkge1xuICAgIGxldCBrID0gaTtcbiAgICBsZXQgazIgPSBrICogMjtcbiAgICB3aGlsZSAoazIgPD0gdGhpcy5uKSB7XG4gICAgICBpZiAoazIgPCB0aGlzLm4gJiYgdGhpcy5ncmVhdGVyKGsyLCBrMiArIDEpKVxuICAgICAgICBrMiArPSAxO1xuICAgICAgaWYgKCF0aGlzLmdyZWF0ZXIoaywgazIpKVxuICAgICAgICBicmVhaztcbiAgICAgIHRoaXMuc3dhcChrLCBrMik7XG4gICAgICBrID0gazI7XG4gICAgICBrMiA9IGsgKiAyO1xuICAgIH1cbiAgfVxuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLm4gKz0gMTtcbiAgICB0aGlzLmhlYXBbdGhpcy5uXSA9IGVsZW1lbnQ7XG4gICAgdGhpcy5zd2ltKHRoaXMubik7XG4gIH1cbiAgcG9wKCkge1xuICAgIGlmICh0aGlzLm4gPT09IDApXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIHRoaXMuc3dhcCgxLCB0aGlzLm4pO1xuICAgIHRoaXMubiAtPSAxO1xuICAgIGNvbnN0IG1heCA9IHRoaXMuaGVhcC5wb3AoKTtcbiAgICB0aGlzLnNpbmsoMSk7XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLm47XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkUHJlY2VkZW50c01hcChncmFwaCwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IHByZWNlZGVudHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB2aXNpdGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc3RvcmVkU2hvcnRlc3RQYXRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0b3JlZFNob3J0ZXN0UGF0aHMuc2V0KHN0YXJ0Tm9kZSwgMCk7XG4gIGNvbnN0IHF1ZXVlID0gbmV3IE1pbkhlYXAocmFua2luZ0Z1bmN0aW9uQ29tcGFyYXRvcigoZWwpID0+IGVsLndlaWdodCkpO1xuICBxdWV1ZS5wdXNoKHsgaWQ6IHN0YXJ0Tm9kZSwgd2VpZ2h0OiAwIH0pO1xuICB3aGlsZSAocXVldWUuc2l6ZSgpID4gMCkge1xuICAgIGNvbnN0IHsgaWQsIHdlaWdodCB9ID0gcXVldWUucG9wKCk7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhpZCkpIHtcbiAgICAgIGNvbnN0IG5laWdoYm9yaW5nTm9kZXMgPSBncmFwaChpZCk7XG4gICAgICB2aXNpdGVkLmFkZChpZCk7XG4gICAgICBuZWlnaGJvcmluZ05vZGVzLmZvckVhY2goKG5laWdoYm9yV2VpZ2h0LCBuZWlnaGJvcikgPT4ge1xuICAgICAgICBjb25zdCBuZXdXZWlnaHQgPSB3ZWlnaHQgKyBuZWlnaGJvcldlaWdodDtcbiAgICAgICAgY29uc3QgY3VycmVudElkID0gcHJlY2VkZW50c01hcC5nZXQobmVpZ2hib3IpO1xuICAgICAgICBjb25zdCBjdXJyZW50V2VpZ2h0ID0gc3RvcmVkU2hvcnRlc3RQYXRocy5nZXQobmVpZ2hib3IpO1xuICAgICAgICBpZiAoY3VycmVudFdlaWdodCA9PT0gdm9pZCAwIHx8IGN1cnJlbnRXZWlnaHQgPiBuZXdXZWlnaHQgJiYgKGN1cnJlbnRXZWlnaHQgLyBuZXdXZWlnaHQgPiAxLjAwNSB8fCBjdXJyZW50SWQgIT09IHZvaWQgMCAmJiBjdXJyZW50SWQgPCBpZCkpIHtcbiAgICAgICAgICBzdG9yZWRTaG9ydGVzdFBhdGhzLnNldChuZWlnaGJvciwgbmV3V2VpZ2h0KTtcbiAgICAgICAgICBxdWV1ZS5wdXNoKHsgaWQ6IG5laWdoYm9yLCB3ZWlnaHQ6IG5ld1dlaWdodCB9KTtcbiAgICAgICAgICBwcmVjZWRlbnRzTWFwLnNldChuZWlnaGJvciwgaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0b3JlZFNob3J0ZXN0UGF0aHMuaGFzKGVuZE5vZGUpID8gcHJlY2VkZW50c01hcCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFBhdGhGcm9tUHJlY2VkZW50c01hcChwcmVjZWRlbnRzTWFwLCBlbmROb2RlKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAobGV0IG5vZGUgPSBlbmROb2RlOyBub2RlICE9PSB2b2lkIDA7IG5vZGUgPSBwcmVjZWRlbnRzTWFwLmdldChub2RlKSkge1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGZpbmRTaG9ydGVzdFBhdGgoZ3JhcGgsIHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xuICBjb25zdCBwcmVjZWRlbnRzTWFwID0gYnVpbGRQcmVjZWRlbnRzTWFwKGdyYXBoLCBzdGFydE5vZGUsIGVuZE5vZGUpO1xuICByZXR1cm4gcHJlY2VkZW50c01hcCA/IGdldFBhdGhGcm9tUHJlY2VkZW50c01hcChwcmVjZWRlbnRzTWFwLCBlbmROb2RlKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGZpbmRJZGVhbE5vZGVTZWFyY2goe1xuICBwaG90b3MsXG4gIHRhcmdldFJvd0hlaWdodCxcbiAgY29udGFpbmVyV2lkdGhcbn0pIHtcbiAgY29uc3QgbWluUmF0aW8gPSBwaG90b3MucmVkdWNlKChhY2MsIHBob3RvKSA9PiBNYXRoLm1pbihyYXRpbyhwaG90byksIGFjYyksIE51bWJlci5NQVhfVkFMVUUpO1xuICByZXR1cm4gcm91bmQoY29udGFpbmVyV2lkdGggLyB0YXJnZXRSb3dIZWlnaHQgLyBtaW5SYXRpbykgKyAyO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uSGVpZ2h0KHJvdywgY29udGFpbmVyV2lkdGgsIHNwYWNpbmcsIHBhZGRpbmcpIHtcbiAgY29uc3Qgcm93V2lkdGggPSBjb250YWluZXJXaWR0aCAtIChyb3cubGVuZ3RoIC0gMSkgKiBzcGFjaW5nIC0gMiAqIHBhZGRpbmcgKiByb3cubGVuZ3RoO1xuICBjb25zdCB0b3RhbEFzcGVjdFJhdGlvID0gcm93LnJlZHVjZSgoYWNjLCBwaG90bykgPT4gYWNjICsgcmF0aW8ocGhvdG8pLCAwKTtcbiAgcmV0dXJuIHJvd1dpZHRoIC8gdG90YWxBc3BlY3RSYXRpbztcbn1cbmZ1bmN0aW9uIGNvc3QocGhvdG9zLCBpLCBqLCB3aWR0aCwgdGFyZ2V0Um93SGVpZ2h0LCBzcGFjaW5nLCBwYWRkaW5nKSB7XG4gIGNvbnN0IHJvdyA9IHBob3Rvcy5zbGljZShpLCBqKTtcbiAgY29uc3QgY29tbW9uSGVpZ2h0ID0gZ2V0Q29tbW9uSGVpZ2h0KHJvdywgd2lkdGgsIHNwYWNpbmcsIHBhZGRpbmcpO1xuICByZXR1cm4gY29tbW9uSGVpZ2h0ID4gMCA/IChjb21tb25IZWlnaHQgLSB0YXJnZXRSb3dIZWlnaHQpICoqIDIgKiByb3cubGVuZ3RoIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gbWFrZUdldFJvd05laWdoYm9ycyh7XG4gIHBob3RvcyxcbiAgbGF5b3V0T3B0aW9ucyxcbiAgdGFyZ2V0Um93SGVpZ2h0LFxuICBsaW1pdE5vZGVTZWFyY2gsXG4gIHJvd0NvbnN0cmFpbnRzXG59KSB7XG4gIHJldHVybiAobm9kZSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBjb250YWluZXJXaWR0aCwgc3BhY2luZywgcGFkZGluZyB9ID0gbGF5b3V0T3B0aW9ucztcbiAgICBjb25zdCByZXN1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICByZXN1bHRzLnNldChub2RlLCAwKTtcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IChfYSA9IHJvd0NvbnN0cmFpbnRzID09IG51bGwgPyB2b2lkIDAgOiByb3dDb25zdHJhaW50cy5taW5QaG90b3MpICE9IG51bGwgPyBfYSA6IDE7XG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gTWF0aC5taW4obGltaXROb2RlU2VhcmNoLCAoX2IgPSByb3dDb25zdHJhaW50cyA9PSBudWxsID8gdm9pZCAwIDogcm93Q29uc3RyYWludHMubWF4UGhvdG9zKSAhPSBudWxsID8gX2IgOiBJbmZpbml0eSk7XG4gICAgZm9yIChsZXQgaSA9IG5vZGUgKyBzdGFydE9mZnNldDsgaSA8IHBob3Rvcy5sZW5ndGggKyAxOyBpICs9IDEpIHtcbiAgICAgIGlmIChpIC0gbm9kZSA+IGVuZE9mZnNldClcbiAgICAgICAgYnJlYWs7XG4gICAgICBjb25zdCBjdXJyZW50Q29zdCA9IGNvc3QocGhvdG9zLCBub2RlLCBpLCBjb250YWluZXJXaWR0aCwgdGFyZ2V0Um93SGVpZ2h0LCBzcGFjaW5nLCBwYWRkaW5nKTtcbiAgICAgIGlmIChjdXJyZW50Q29zdCA9PT0gdm9pZCAwKVxuICAgICAgICBicmVhaztcbiAgICAgIHJlc3VsdHMuc2V0KGksIGN1cnJlbnRDb3N0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlUm93c0xheW91dCh7XG4gIHBob3RvcyxcbiAgbGF5b3V0T3B0aW9uc1xufSkge1xuICBjb25zdCB7IHNwYWNpbmcsIHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoLCB0YXJnZXRSb3dIZWlnaHQsIHJvd0NvbnN0cmFpbnRzIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCBsaW1pdE5vZGVTZWFyY2ggPSBmaW5kSWRlYWxOb2RlU2VhcmNoKHsgcGhvdG9zLCBjb250YWluZXJXaWR0aCwgdGFyZ2V0Um93SGVpZ2h0IH0pO1xuICBjb25zdCBnZXROZWlnaGJvcnMgPSBtYWtlR2V0Um93TmVpZ2hib3JzKHtcbiAgICBwaG90b3MsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICB0YXJnZXRSb3dIZWlnaHQsXG4gICAgbGltaXROb2RlU2VhcmNoLFxuICAgIHJvd0NvbnN0cmFpbnRzXG4gIH0pO1xuICBjb25zdCBwYXRoID0gZmluZFNob3J0ZXN0UGF0aChnZXROZWlnaGJvcnMsIDAsIHBob3Rvcy5sZW5ndGgpO1xuICBpZiAocGF0aCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IGxheW91dCA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHBhdGgubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCByb3cgPSBwaG90b3MubWFwKChwaG90bywgaW5kZXgpID0+ICh7IHBob3RvLCBpbmRleCB9KSkuc2xpY2UocGF0aFtpIC0gMV0sIHBhdGhbaV0pO1xuICAgIGNvbnN0IGhlaWdodCA9IGdldENvbW1vbkhlaWdodChcbiAgICAgIHJvdy5tYXAoKHsgcGhvdG8gfSkgPT4gcGhvdG8pLFxuICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICBzcGFjaW5nLFxuICAgICAgcGFkZGluZ1xuICAgICk7XG4gICAgbGF5b3V0LnB1c2goXG4gICAgICByb3cubWFwKCh7IHBob3RvLCBpbmRleCB9LCBwaG90b0luZGV4KSA9PiAoe1xuICAgICAgICBwaG90byxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBoZWlnaHQgKiByYXRpbyhwaG90byksXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcGhvdG9JbmRleCxcbiAgICAgICAgICBwaG90b3NDb3VudDogcm93Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIHJldHVybiBsYXlvdXQ7XG59XG5mdW5jdGlvbiBjbHN4KC4uLmNsYXNzZXMpIHtcbiAgcmV0dXJuIFsuLi5jbGFzc2VzXS5maWx0ZXIoKGNscykgPT4gQm9vbGVhbihjbHMpKS5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIGNhbGNXaWR0aChiYXNlLCB7IHdpZHRoLCBwaG90b3NDb3VudCB9LCB7IHNwYWNpbmcsIHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoIH0pIHtcbiAgY29uc3QgZ2FwcyA9IHNwYWNpbmcgKiAocGhvdG9zQ291bnQgLSAxKSArIDIgKiBwYWRkaW5nICogcGhvdG9zQ291bnQ7XG4gIHJldHVybiBgY2FsYygoJHtiYXNlfSAtICR7Z2Fwc31weCkgLyAke3JvdW5kKChjb250YWluZXJXaWR0aCAtIGdhcHMpIC8gd2lkdGgsIDUpfSlgO1xufVxuZnVuY3Rpb24gY3NzUGhvdG9XaWR0aChsYXlvdXQsIGxheW91dE9wdGlvbnMpIHtcbiAgcmV0dXJuIGxheW91dE9wdGlvbnMubGF5b3V0ICE9PSBcInJvd3NcIiA/IGBjYWxjKDEwMCUgLSAkezIgKiBsYXlvdXRPcHRpb25zLnBhZGRpbmd9cHgpYCA6IGNhbGNXaWR0aChcIjEwMCVcIiwgbGF5b3V0LCBsYXlvdXRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpemVzVmFsdWUoc2l6ZSwgbGF5b3V0LCBsYXlvdXRPcHRpb25zKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiBjYWxjV2lkdGgoKF9iID0gKF9hID0gc2l6ZS5tYXRjaCgvXlxccypjYWxjXFwoKC4qKVxcKVxccyokLykpID09IG51bGwgPyB2b2lkIDAgOiBfYVsxXSkgIT0gbnVsbCA/IF9iIDogc2l6ZSwgbGF5b3V0LCBsYXlvdXRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNyY1NldEFuZFNpemVzKHBob3RvLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpIHtcbiAgbGV0IHNyY1NldDtcbiAgbGV0IHNpemVzO1xuICBjb25zdCBpbWFnZXMgPSBwaG90by5zcmNTZXQgfHwgcGhvdG8uaW1hZ2VzO1xuICBpZiAoaW1hZ2VzICYmIGltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgc3JjU2V0ID0gaW1hZ2VzLmNvbmNhdChcbiAgICAgICFpbWFnZXMuZmluZCgoeyB3aWR0aCB9KSA9PiB3aWR0aCA9PT0gcGhvdG8ud2lkdGgpID8gW3sgc3JjOiBwaG90by5zcmMsIHdpZHRoOiBwaG90by53aWR0aCwgaGVpZ2h0OiBwaG90by5oZWlnaHQgfV0gOiBbXVxuICAgICkuc29ydCgoZmlyc3QsIHNlY29uZCkgPT4gZmlyc3Qud2lkdGggLSBzZWNvbmQud2lkdGgpLm1hcCgoaW1hZ2UpID0+IGAke2ltYWdlLnNyY30gJHtpbWFnZS53aWR0aH13YCkuam9pbihcIiwgXCIpO1xuICB9XG4gIGlmIChsYXlvdXRPcHRpb25zLnNpemVzKSB7XG4gICAgc2l6ZXMgPSAobGF5b3V0T3B0aW9ucy5zaXplcy5zaXplcyB8fCBbXSkubWFwKCh7IHZpZXdwb3J0LCBzaXplIH0pID0+IGAke3ZpZXdwb3J0fSAke2NhbGN1bGF0ZVNpemVzVmFsdWUoc2l6ZSwgbGF5b3V0LCBsYXlvdXRPcHRpb25zKX1gKS5jb25jYXQoY2FsY3VsYXRlU2l6ZXNWYWx1ZShsYXlvdXRPcHRpb25zLnNpemVzLnNpemUsIGxheW91dCwgbGF5b3V0T3B0aW9ucykpLmpvaW4oXCIsIFwiKTtcbiAgfSBlbHNlIGlmIChzcmNTZXQpIHtcbiAgICBzaXplcyA9IGAke01hdGguY2VpbChsYXlvdXQud2lkdGggLyBsYXlvdXRPcHRpb25zLmNvbnRhaW5lcldpZHRoICogMTAwKX12d2A7XG4gIH1cbiAgcmV0dXJuIHsgc3JjU2V0LCBzaXplcyB9O1xufVxuZnVuY3Rpb24gUGhvdG9SZW5kZXJlcihwcm9wcykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB7IHBob3RvLCBsYXlvdXQsIGxheW91dE9wdGlvbnMsIGltYWdlUHJvcHM6IHsgc3R5bGUsIGNsYXNzTmFtZSwgLi4ucmVzdEltYWdlUHJvcHMgfSA9IHt9LCByZW5kZXJQaG90byB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgb25DbGljayB9ID0gbGF5b3V0T3B0aW9ucztcbiAgY29uc3QgaW1hZ2VTdHlsZSA9IHtcbiAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgYm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCIsXG4gICAgd2lkdGg6IGNzc1Bob3RvV2lkdGgobGF5b3V0LCBsYXlvdXRPcHRpb25zKSxcbiAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgIGFzcGVjdFJhdGlvOiBgJHtwaG90by53aWR0aH0gLyAke3Bob3RvLmhlaWdodH1gLFxuICAgIC4uLmxheW91dE9wdGlvbnMucGFkZGluZyA/IHsgcGFkZGluZzogYCR7bGF5b3V0T3B0aW9ucy5wYWRkaW5nfXB4YCB9IDogbnVsbCxcbiAgICAuLi4obGF5b3V0T3B0aW9ucy5sYXlvdXQgPT09IFwiY29sdW1uc1wiIHx8IGxheW91dE9wdGlvbnMubGF5b3V0ID09PSBcIm1hc29ucnlcIikgJiYgbGF5b3V0LnBob3RvSW5kZXggPCBsYXlvdXQucGhvdG9zQ291bnQgLSAxID8geyBtYXJnaW5Cb3R0b206IGAke2xheW91dE9wdGlvbnMuc3BhY2luZ31weGAgfSA6IG51bGwsXG4gICAgLi4ub25DbGljayA/IHsgY3Vyc29yOiBcInBvaW50ZXJcIiB9IDogbnVsbCxcbiAgICAuLi5zdHlsZVxuICB9O1xuICBjb25zdCBoYW5kbGVDbGljayA9IG9uQ2xpY2sgPyAoZXZlbnQpID0+IHtcbiAgICBvbkNsaWNrKHsgZXZlbnQsIHBob3RvLCBpbmRleDogbGF5b3V0LmluZGV4IH0pO1xuICB9IDogdm9pZCAwO1xuICBjb25zdCBpbWFnZVByb3BzID0ge1xuICAgIHNyYzogcGhvdG8uc3JjLFxuICAgIGFsdDogKF9hID0gcGhvdG8uYWx0KSAhPSBudWxsID8gX2EgOiBcIlwiLFxuICAgIHRpdGxlOiBwaG90by50aXRsZSxcbiAgICBvbkNsaWNrOiBoYW5kbGVDbGljayxcbiAgICBzdHlsZTogaW1hZ2VTdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsc3goXCJyZWFjdC1waG90by1hbGJ1bS0tcGhvdG9cIiwgY2xhc3NOYW1lKSxcbiAgICBsb2FkaW5nOiBcImxhenlcIixcbiAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgIC4uLnNyY1NldEFuZFNpemVzKHBob3RvLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpLFxuICAgIC4uLnJlc3RJbWFnZVByb3BzXG4gIH07XG4gIGNvbnN0IHJlbmRlckRlZmF1bHRQaG90byA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBzcmMsIGFsdCwgc3JjU2V0LCBzaXplcywgc3R5bGU6IHVud3JhcHBlZFN0eWxlLCAuLi5yZXN0IH0gPSBpbWFnZVByb3BzO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJpbWdcIixcbiAgICAgIHtcbiAgICAgICAgYWx0LFxuICAgICAgICAuLi5zcmNTZXQgPyB7IHNyY1NldCwgc2l6ZXMgfSA6IG51bGwsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3R5bGU6IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLndyYXBwZWQpID8geyBkaXNwbGF5OiBcImJsb2NrXCIsIHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiB9IDogdW53cmFwcGVkU3R5bGUsXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH1cbiAgICApO1xuICB9O1xuICBjb25zdCB3cmFwcGVyU3R5bGUgPSAoKHsgZGlzcGxheSwgYm94U2l6aW5nLCB3aWR0aCwgYXNwZWN0UmF0aW8sIHBhZGRpbmcsIG1hcmdpbkJvdHRvbSwgY3Vyc29yIH0pID0+ICh7XG4gICAgZGlzcGxheSxcbiAgICBib3hTaXppbmcsXG4gICAgd2lkdGgsXG4gICAgYXNwZWN0UmF0aW8sXG4gICAgcGFkZGluZyxcbiAgICBtYXJnaW5Cb3R0b20sXG4gICAgY3Vyc29yXG4gIH0pKShpbWFnZVN0eWxlKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIChfYiA9IHJlbmRlclBob3RvID09IG51bGwgPyB2b2lkIDAgOiByZW5kZXJQaG90byh7XG4gICAgcGhvdG8sXG4gICAgbGF5b3V0LFxuICAgIGxheW91dE9wdGlvbnMsXG4gICAgaW1hZ2VQcm9wcyxcbiAgICByZW5kZXJEZWZhdWx0UGhvdG8sXG4gICAgd3JhcHBlclN0eWxlXG4gIH0pKSAhPSBudWxsID8gX2IgOiByZW5kZXJEZWZhdWx0UGhvdG8oKSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyUm93Q29udGFpbmVyKHtcbiAgcm93Q29udGFpbmVyUHJvcHMsXG4gIGNoaWxkcmVuXG59KSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgLi4ucm93Q29udGFpbmVyUHJvcHMgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gUm93Q29udGFpbmVyUmVuZGVyZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGxheW91dE9wdGlvbnMsXG4gICAgcm93SW5kZXgsXG4gICAgcm93c0NvdW50LFxuICAgIHJlbmRlclJvd0NvbnRhaW5lcixcbiAgICByb3dDb250YWluZXJQcm9wczogeyBzdHlsZSwgY2xhc3NOYW1lLCAuLi5yZXN0Um93Q29udGFpbmVyUHJvcHMgfSA9IHt9LFxuICAgIGNoaWxkcmVuXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgcm93Q29udGFpbmVyUHJvcHMgPSB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KFwicmVhY3QtcGhvdG8tYWxidW0tLXJvd1wiLCBjbGFzc05hbWUpLFxuICAgIHN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgIGZsZXhEaXJlY3Rpb246IFwicm93XCIsXG4gICAgICBmbGV4V3JhcDogXCJub3dyYXBcIixcbiAgICAgIGFsaWduSXRlbXM6IFwiZmxleC1zdGFydFwiLFxuICAgICAganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLFxuICAgICAgLi4ucm93SW5kZXggPCByb3dzQ291bnQgLSAxID8geyBtYXJnaW5Cb3R0b206IGAke2xheW91dE9wdGlvbnMuc3BhY2luZ31weGAgfSA6IG51bGwsXG4gICAgICAuLi5zdHlsZVxuICAgIH0sXG4gICAgLi4ucmVzdFJvd0NvbnRhaW5lclByb3BzXG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAocmVuZGVyUm93Q29udGFpbmVyICE9IG51bGwgPyByZW5kZXJSb3dDb250YWluZXIgOiBkZWZhdWx0UmVuZGVyUm93Q29udGFpbmVyKSh7XG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICByb3dJbmRleCxcbiAgICByb3dzQ291bnQsXG4gICAgcm93Q29udGFpbmVyUHJvcHMsXG4gICAgY2hpbGRyZW5cbiAgfSkpO1xufVxuZnVuY3Rpb24gUm93c0xheW91dChwcm9wcykge1xuICBjb25zdCB7XG4gICAgcGhvdG9zLFxuICAgIGxheW91dE9wdGlvbnMsXG4gICAgcmVuZGVyUGhvdG8sXG4gICAgcmVuZGVyUm93Q29udGFpbmVyLFxuICAgIGNvbXBvbmVudHNQcm9wczogeyBpbWFnZVByb3BzLCByb3dDb250YWluZXJQcm9wcyB9XG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgcm93c0xheW91dCA9IGNvbXB1dGVSb3dzTGF5b3V0KHsgcGhvdG9zLCBsYXlvdXRPcHRpb25zIH0pO1xuICBpZiAoIXJvd3NMYXlvdXQpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByb3dzTGF5b3V0Lm1hcCgocm93LCByb3dJbmRleCkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBSb3dDb250YWluZXJSZW5kZXJlcixcbiAgICB7XG4gICAgICBrZXk6IGByb3ctJHtyb3dJbmRleH1gLFxuICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgIHJvd0luZGV4LFxuICAgICAgcm93c0NvdW50OiByb3dzTGF5b3V0Lmxlbmd0aCxcbiAgICAgIHJlbmRlclJvd0NvbnRhaW5lcixcbiAgICAgIHJvd0NvbnRhaW5lclByb3BzXG4gICAgfSxcbiAgICByb3cubWFwKCh7IHBob3RvLCBsYXlvdXQgfSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFBob3RvUmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGtleTogcGhvdG8ua2V5IHx8IHBob3RvLnNyYyxcbiAgICAgICAgcGhvdG8sXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgICAgcmVuZGVyUGhvdG8sXG4gICAgICAgIGltYWdlUHJvcHNcbiAgICAgIH1cbiAgICApKVxuICApKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2hvcnRlc3RQYXRoKGdyYXBoLCBwYXRoTGVuZ3RoLCBzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgY29uc3QgbWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgcXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBxdWV1ZS5hZGQoc3RhcnROb2RlKTtcbiAgZm9yIChsZXQgbGVuZ3RoID0gMDsgbGVuZ3RoIDwgcGF0aExlbmd0aDsgbGVuZ3RoICs9IDEpIHtcbiAgICBjb25zdCBjdXJyZW50UXVldWUgPSBbLi4ucXVldWUua2V5cygpXTtcbiAgICBxdWV1ZS5jbGVhcigpO1xuICAgIGN1cnJlbnRRdWV1ZS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBjb25zdCBhY2N1bXVsYXRlZFdlaWdodCA9IGxlbmd0aCA+IDAgPyBtYXRyaXguZ2V0KG5vZGUpW2xlbmd0aF0ud2VpZ2h0IDogMDtcbiAgICAgIGdyYXBoKG5vZGUpLmZvckVhY2goKHsgbmVpZ2hib3IsIHdlaWdodCB9KSA9PiB7XG4gICAgICAgIGxldCBwYXRocyA9IG1hdHJpeC5nZXQobmVpZ2hib3IpO1xuICAgICAgICBpZiAoIXBhdGhzKSB7XG4gICAgICAgICAgcGF0aHMgPSBbXTtcbiAgICAgICAgICBtYXRyaXguc2V0KG5laWdoYm9yLCBwYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3V2VpZ2h0ID0gYWNjdW11bGF0ZWRXZWlnaHQgKyB3ZWlnaHQ7XG4gICAgICAgIGNvbnN0IG5leHRQYXRoID0gcGF0aHNbbGVuZ3RoICsgMV07XG4gICAgICAgIGlmICghbmV4dFBhdGggfHwgbmV4dFBhdGgud2VpZ2h0ID4gbmV3V2VpZ2h0ICYmIChuZXh0UGF0aC53ZWlnaHQgLyBuZXdXZWlnaHQgPiAxLjAwMDEgfHwgbm9kZSA8IG5leHRQYXRoLm5vZGUpKSB7XG4gICAgICAgICAgcGF0aHNbbGVuZ3RoICsgMV0gPSB7IG5vZGUsIHdlaWdodDogbmV3V2VpZ2h0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IHBhdGhMZW5ndGggLSAxICYmIG5laWdoYm9yICE9PSBlbmROb2RlKSB7XG4gICAgICAgICAgcXVldWUuYWRkKG5laWdoYm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG1hdHJpeDtcbn1cbmZ1bmN0aW9uIHJlY29uc3RydWN0U2hvcnRlc3RQYXRoKG1hdHJpeCwgcGF0aExlbmd0aCwgZW5kTm9kZSkge1xuICBjb25zdCBwYXRoID0gW2VuZE5vZGVdO1xuICBmb3IgKGxldCBub2RlID0gZW5kTm9kZSwgbGVuZ3RoID0gcGF0aExlbmd0aDsgbGVuZ3RoID4gMDsgbGVuZ3RoIC09IDEpIHtcbiAgICBub2RlID0gbWF0cml4LmdldChub2RlKVtsZW5ndGhdLm5vZGU7XG4gICAgcGF0aC5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBwYXRoLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIGZpbmRTaG9ydGVzdFBhdGhMZW5ndGhOKGdyYXBoLCBwYXRoTGVuZ3RoLCBzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuIHJlY29uc3RydWN0U2hvcnRlc3RQYXRoKGNvbXB1dGVTaG9ydGVzdFBhdGgoZ3JhcGgsIHBhdGhMZW5ndGgsIHN0YXJ0Tm9kZSwgZW5kTm9kZSksIHBhdGhMZW5ndGgsIGVuZE5vZGUpO1xufVxuZnVuY3Rpb24gbWFrZUdldENvbHVtbk5laWdoYm9ycyh7XG4gIHBob3RvcyxcbiAgc3BhY2luZyxcbiAgcGFkZGluZyxcbiAgdGFyZ2V0Q29sdW1uV2lkdGgsXG4gIHRhcmdldENvbHVtbkhlaWdodFxufSkge1xuICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgY3V0T2ZmSGVpZ2h0ID0gdGFyZ2V0Q29sdW1uSGVpZ2h0ICogMS41O1xuICAgIGxldCBoZWlnaHQgPSB0YXJnZXRDb2x1bW5XaWR0aCAvIHJhdGlvKHBob3Rvc1tub2RlXSkgKyAyICogcGFkZGluZztcbiAgICBmb3IgKGxldCBpID0gbm9kZSArIDE7IGkgPCBwaG90b3MubGVuZ3RoICsgMTsgaSArPSAxKSB7XG4gICAgICByZXN1bHRzLnB1c2goeyBuZWlnaGJvcjogaSwgd2VpZ2h0OiAodGFyZ2V0Q29sdW1uSGVpZ2h0IC0gaGVpZ2h0KSAqKiAyIH0pO1xuICAgICAgaWYgKGhlaWdodCA+IGN1dE9mZkhlaWdodCB8fCBpID09PSBwaG90b3MubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaGVpZ2h0ICs9IHRhcmdldENvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG9zW2ldKSArIHNwYWNpbmcgKyAyICogcGFkZGluZztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZENvbHVtbnNNb2RlbCh7XG4gIHBhdGgsXG4gIHBob3RvcyxcbiAgY29udGFpbmVyV2lkdGgsXG4gIGNvbHVtbnNHYXBzLFxuICBjb2x1bW5zUmF0aW9zLFxuICBzcGFjaW5nLFxuICBwYWRkaW5nXG59KSB7XG4gIGNvbnN0IGNvbHVtbnNNb2RlbCA9IFtdO1xuICBjb25zdCB0b3RhbFJhdGlvID0gY29sdW1uc1JhdGlvcy5yZWR1Y2UoKHRvdGFsLCBjb2x1bW5SYXRpbykgPT4gdG90YWwgKyBjb2x1bW5SYXRpbywgMCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICBjb25zdCBjb2x1bW4gPSBwaG90b3MubWFwKChwaG90bywgaW5kZXgpID0+ICh7IHBob3RvLCBpbmRleCB9KSkuc2xpY2UocGF0aFtpXSwgcGF0aFtpICsgMV0pO1xuICAgIGNvbnN0IHRvdGFsQWRqdXN0ZWRHYXBzID0gY29sdW1uc1JhdGlvcy5yZWR1Y2UoXG4gICAgICAodG90YWwsIGNvbHVtblJhdGlvLCBpbmRleCkgPT4gdG90YWwgKyAoY29sdW1uc0dhcHNbaV0gLSBjb2x1bW5zR2Fwc1tpbmRleF0pICogY29sdW1uUmF0aW8sXG4gICAgICAwXG4gICAgKTtcbiAgICBjb25zdCBjb2x1bW5XaWR0aCA9IChjb250YWluZXJXaWR0aCAtIChwYXRoLmxlbmd0aCAtIDIpICogc3BhY2luZyAtIDIgKiAocGF0aC5sZW5ndGggLSAxKSAqIHBhZGRpbmcgLSB0b3RhbEFkanVzdGVkR2FwcykgKiBjb2x1bW5zUmF0aW9zW2ldIC8gdG90YWxSYXRpbztcbiAgICBjb2x1bW5zTW9kZWwucHVzaChcbiAgICAgIGNvbHVtbi5tYXAoKHsgcGhvdG8sIGluZGV4IH0sIHBob3RvSW5kZXgpID0+ICh7XG4gICAgICAgIHBob3RvLFxuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjb2x1bW5XaWR0aCAvIHJhdGlvKHBob3RvKSxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBwaG90b0luZGV4LFxuICAgICAgICAgIHBob3Rvc0NvdW50OiBjb2x1bW4ubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbHVtbnNNb2RlbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb2x1bW5zTW9kZWwoe1xuICBwaG90b3MsXG4gIGxheW91dE9wdGlvbnMsXG4gIHRhcmdldENvbHVtbldpZHRoXG59KSB7XG4gIGNvbnN0IHsgY29sdW1ucywgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGggfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGNvbHVtbnNHYXBzID0gW107XG4gIGNvbnN0IGNvbHVtbnNSYXRpb3MgPSBbXTtcbiAgaWYgKHBob3Rvcy5sZW5ndGggPD0gY29sdW1ucykge1xuICAgIGNvbnN0IGF2ZXJhZ2VSYXRpbyA9IHBob3Rvcy5sZW5ndGggPiAwID8gcGhvdG9zLnJlZHVjZSgoYWNjLCBwaG90bykgPT4gYWNjICsgcmF0aW8ocGhvdG8pLCAwKSAvIHBob3Rvcy5sZW5ndGggOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSArPSAxKSB7XG4gICAgICBjb2x1bW5zR2Fwc1tpXSA9IDIgKiBwYWRkaW5nO1xuICAgICAgY29sdW1uc1JhdGlvc1tpXSA9IGkgPCBwaG90b3MubGVuZ3RoID8gcmF0aW8ocGhvdG9zW2ldKSA6IGF2ZXJhZ2VSYXRpbztcbiAgICB9XG4gICAgY29uc3QgY29sdW1uc01vZGVsMiA9IGJ1aWxkQ29sdW1uc01vZGVsKHtcbiAgICAgIHBhdGg6IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHVtbnMgKyAxIH0pLm1hcCgoXywgaW5kZXgpID0+IE1hdGgubWluKGluZGV4LCBwaG90b3MubGVuZ3RoKSksXG4gICAgICBwaG90b3MsXG4gICAgICBjb2x1bW5zUmF0aW9zLFxuICAgICAgY29sdW1uc0dhcHMsXG4gICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgIHNwYWNpbmcsXG4gICAgICBwYWRkaW5nXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MsIGNvbHVtbnNNb2RlbDogY29sdW1uc01vZGVsMiB9O1xuICB9XG4gIGNvbnN0IHRhcmdldENvbHVtbkhlaWdodCA9IChwaG90b3MucmVkdWNlKChhY2MsIHBob3RvKSA9PiBhY2MgKyB0YXJnZXRDb2x1bW5XaWR0aCAvIHJhdGlvKHBob3RvKSwgMCkgKyBzcGFjaW5nICogKHBob3Rvcy5sZW5ndGggLSBjb2x1bW5zKSArIDIgKiBwYWRkaW5nICogcGhvdG9zLmxlbmd0aCkgLyBjb2x1bW5zO1xuICBjb25zdCBnZXROZWlnaGJvcnMgPSBtYWtlR2V0Q29sdW1uTmVpZ2hib3JzKHtcbiAgICBwaG90b3MsXG4gICAgdGFyZ2V0Q29sdW1uV2lkdGgsXG4gICAgdGFyZ2V0Q29sdW1uSGVpZ2h0LFxuICAgIHNwYWNpbmcsXG4gICAgcGFkZGluZ1xuICB9KTtcbiAgY29uc3QgcGF0aCA9IGZpbmRTaG9ydGVzdFBhdGhMZW5ndGhOKGdldE5laWdoYm9ycywgY29sdW1ucywgMCwgcGhvdG9zLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICBjb25zdCBjb2x1bW4gPSBwaG90b3Muc2xpY2UocGF0aFtpXSwgcGF0aFtpICsgMV0pO1xuICAgIGNvbHVtbnNHYXBzW2ldID0gc3BhY2luZyAqIChjb2x1bW4ubGVuZ3RoIC0gMSkgKyAyICogcGFkZGluZyAqIGNvbHVtbi5sZW5ndGg7XG4gICAgY29sdW1uc1JhdGlvc1tpXSA9IDEgLyBjb2x1bW4ucmVkdWNlKChhY2MsIHBob3RvKSA9PiBhY2MgKyAxIC8gcmF0aW8ocGhvdG8pLCAwKTtcbiAgfVxuICBjb25zdCBjb2x1bW5zTW9kZWwgPSBidWlsZENvbHVtbnNNb2RlbCh7XG4gICAgcGF0aCxcbiAgICBwaG90b3MsXG4gICAgY29sdW1uc1JhdGlvcyxcbiAgICBjb2x1bW5zR2FwcyxcbiAgICBjb250YWluZXJXaWR0aCxcbiAgICBzcGFjaW5nLFxuICAgIHBhZGRpbmdcbiAgfSk7XG4gIHJldHVybiB7IGNvbHVtbnNHYXBzLCBjb2x1bW5zUmF0aW9zLCBjb2x1bW5zTW9kZWwgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMYXlvdXQocHJvcHMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSA9IHByb3BzO1xuICBjb25zdCB7IGNvbHVtbnMsIHNwYWNpbmcsIHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCB0YXJnZXRDb2x1bW5XaWR0aCA9IChjb250YWluZXJXaWR0aCAtIHNwYWNpbmcgKiAoY29sdW1ucyAtIDEpIC0gMiAqIHBhZGRpbmcgKiBjb2x1bW5zKSAvIGNvbHVtbnM7XG4gIGNvbnN0IHsgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MsIGNvbHVtbnNNb2RlbCB9ID0gY29tcHV0ZUNvbHVtbnNNb2RlbCh7XG4gICAgcGhvdG9zLFxuICAgIGxheW91dE9wdGlvbnMsXG4gICAgdGFyZ2V0Q29sdW1uV2lkdGhcbiAgfSk7XG4gIGlmIChjb2x1bW5zTW9kZWwuZmluZEluZGV4KFxuICAgIChjb2x1bW5Nb2RlbCkgPT4gY29sdW1uTW9kZWwuZmluZEluZGV4KCh7IGxheW91dDogeyB3aWR0aCwgaGVpZ2h0IH0gfSkgPT4gd2lkdGggPCAwIHx8IGhlaWdodCA8IDApID49IDBcbiAgKSA+PSAwKSB7XG4gICAgaWYgKGNvbHVtbnMgPiAxKSB7XG4gICAgICByZXR1cm4gY29tcHV0ZUxheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9uczogeyAuLi5sYXlvdXRPcHRpb25zLCBjb2x1bW5zOiBjb2x1bW5zIC0gMSB9IH0pO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7IGNvbHVtbnNNb2RlbCwgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDb2x1bW5zTGF5b3V0KHtcbiAgcGhvdG9zLFxuICBsYXlvdXRPcHRpb25zXG59KSB7XG4gIHJldHVybiBjb21wdXRlTGF5b3V0KHsgcGhvdG9zLCBsYXlvdXRPcHRpb25zIH0pO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNvbHVtbkNvbnRhaW5lcih7XG4gIGNvbHVtbkNvbnRhaW5lclByb3BzLFxuICBjaGlsZHJlblxufSkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLmNvbHVtbkNvbnRhaW5lclByb3BzIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIGNzc0NvbHVtbldpZHRoKHByb3BzKSB7XG4gIGNvbnN0IHsgbGF5b3V0T3B0aW9ucywgY29sdW1uSW5kZXgsIGNvbHVtbnNDb3VudCwgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MgfSA9IHByb3BzO1xuICBjb25zdCB7IGxheW91dCwgc3BhY2luZywgcGFkZGluZyB9ID0gbGF5b3V0T3B0aW9ucztcbiAgaWYgKGxheW91dCA9PT0gXCJtYXNvbnJ5XCIgfHwgIWNvbHVtbnNHYXBzIHx8ICFjb2x1bW5zUmF0aW9zKSB7XG4gICAgcmV0dXJuIGBjYWxjKCgxMDAlIC0gJHtzcGFjaW5nICogKGNvbHVtbnNDb3VudCAtIDEpfXB4KSAvICR7Y29sdW1uc0NvdW50fSlgO1xuICB9XG4gIGNvbnN0IHRvdGFsUmF0aW8gPSBjb2x1bW5zUmF0aW9zLnJlZHVjZSgoYWNjLCByYXRpbzIpID0+IGFjYyArIHJhdGlvMiwgMCk7XG4gIGNvbnN0IHRvdGFsQWRqdXN0ZWRHYXBzID0gY29sdW1uc1JhdGlvcy5yZWR1Y2UoXG4gICAgKGFjYywgcmF0aW8yLCBpbmRleCkgPT4gYWNjICsgKGNvbHVtbnNHYXBzW2NvbHVtbkluZGV4XSAtIGNvbHVtbnNHYXBzW2luZGV4XSkgKiByYXRpbzIsXG4gICAgMFxuICApO1xuICByZXR1cm4gYGNhbGMoKDEwMCUgLSAke3JvdW5kKFxuICAgIChjb2x1bW5zQ291bnQgLSAxKSAqIHNwYWNpbmcgKyAyICogY29sdW1uc0NvdW50ICogcGFkZGluZyArIHRvdGFsQWRqdXN0ZWRHYXBzLFxuICAgIDNcbiAgKX1weCkgKiAke3JvdW5kKGNvbHVtbnNSYXRpb3NbY29sdW1uSW5kZXhdIC8gdG90YWxSYXRpbywgNSl9ICsgJHsyICogcGFkZGluZ31weClgO1xufVxuZnVuY3Rpb24gQ29sdW1uQ29udGFpbmVyUmVuZGVyZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGxheW91dE9wdGlvbnMsXG4gICAgcmVuZGVyQ29sdW1uQ29udGFpbmVyLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbHVtbkNvbnRhaW5lclByb3BzOiB7IHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3RDb2x1bW5Db250YWluZXJQcm9wcyB9ID0ge30sXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbHVtbkNvbnRhaW5lclByb3BzID0ge1xuICAgIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LXBob3RvLWFsYnVtLS1jb2x1bW5cIiwgY2xhc3NOYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIixcbiAgICAgIHdpZHRoOiBjc3NDb2x1bW5XaWR0aChwcm9wcyksXG4gICAgICBqdXN0aWZ5Q29udGVudDogbGF5b3V0T3B0aW9ucy5sYXlvdXQgPT09IFwiY29sdW1uc1wiID8gXCJzcGFjZS1iZXR3ZWVuXCIgOiBcImZsZXgtc3RhcnRcIixcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICAuLi5yZXN0Q29sdW1uQ29udGFpbmVyUHJvcHNcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIChyZW5kZXJDb2x1bW5Db250YWluZXIgIT0gbnVsbCA/IHJlbmRlckNvbHVtbkNvbnRhaW5lciA6IGRlZmF1bHRSZW5kZXJDb2x1bW5Db250YWluZXIpKHtcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIGNvbHVtbkNvbnRhaW5lclByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIC4uLnJlc3RcbiAgfSkpO1xufVxuZnVuY3Rpb24gQ29sdW1uc0xheW91dChwcm9wcykge1xuICBjb25zdCB7XG4gICAgcGhvdG9zLFxuICAgIGxheW91dE9wdGlvbnMsXG4gICAgcmVuZGVyUGhvdG8sXG4gICAgcmVuZGVyQ29sdW1uQ29udGFpbmVyLFxuICAgIGNvbXBvbmVudHNQcm9wczogeyBpbWFnZVByb3BzLCBjb2x1bW5Db250YWluZXJQcm9wcyB9XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgY29sdW1uc0xheW91dCA9IGNvbXB1dGVDb2x1bW5zTGF5b3V0KHsgcGhvdG9zLCBsYXlvdXRPcHRpb25zIH0pO1xuICBpZiAoIWNvbHVtbnNMYXlvdXQpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHsgY29sdW1uc01vZGVsLCBjb2x1bW5zUmF0aW9zLCBjb2x1bW5zR2FwcyB9ID0gY29sdW1uc0xheW91dDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNvbHVtbnNNb2RlbC5tYXAoKGNvbHVtbiwgY29sdW1uSW5kZXgpID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgQ29sdW1uQ29udGFpbmVyUmVuZGVyZXIsXG4gICAge1xuICAgICAga2V5OiBgY29sdW1uLSR7Y29sdW1uSW5kZXh9YCxcbiAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICBjb2x1bW5JbmRleCxcbiAgICAgIGNvbHVtbnNDb3VudDogY29sdW1uc01vZGVsLmxlbmd0aCxcbiAgICAgIGNvbHVtbnNHYXBzLFxuICAgICAgY29sdW1uc1JhdGlvcyxcbiAgICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICAgIGNvbHVtbkNvbnRhaW5lclByb3BzXG4gICAgfSxcbiAgICBjb2x1bW4ubWFwKCh7IHBob3RvLCBsYXlvdXQgfSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFBob3RvUmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGtleTogcGhvdG8ua2V5IHx8IHBob3RvLnNyYyxcbiAgICAgICAgcGhvdG8sXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgICAgcmVuZGVyUGhvdG8sXG4gICAgICAgIGltYWdlUHJvcHNcbiAgICAgIH1cbiAgICApKVxuICApKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTWFzb25yeUxheW91dChwcm9wcykge1xuICBjb25zdCB7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgY29sdW1ucywgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGggfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGNvbHVtbldpZHRoID0gKGNvbnRhaW5lcldpZHRoIC0gc3BhY2luZyAqIChjb2x1bW5zIC0gMSkgLSAyICogcGFkZGluZyAqIGNvbHVtbnMpIC8gY29sdW1ucztcbiAgaWYgKGNvbHVtbldpZHRoIDw9IDApIHtcbiAgICByZXR1cm4gY29sdW1ucyA+IDEgPyBjb21wdXRlTWFzb25yeUxheW91dCh7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIGxheW91dE9wdGlvbnM6IHsgLi4ubGF5b3V0T3B0aW9ucywgY29sdW1uczogY29sdW1ucyAtIDEgfVxuICAgIH0pIDogdm9pZCAwO1xuICB9XG4gIGNvbnN0IGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSArPSAxKSB7XG4gICAgY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbaV0gPSAwO1xuICB9XG4gIGNvbnN0IGNvbHVtbnNNb2RlbCA9IHBob3Rvcy5yZWR1Y2UoXG4gICAgKG1vZGVsLCBwaG90bywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNob3J0ZXN0Q29sdW1uID0gY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnMucmVkdWNlKFxuICAgICAgICAoY3VycmVudFNob3J0ZXN0Q29sdW1uLCBpdGVtLCBpKSA9PiBpdGVtIDwgY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbY3VycmVudFNob3J0ZXN0Q29sdW1uXSAtIDEgPyBpIDogY3VycmVudFNob3J0ZXN0Q29sdW1uLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbc2hvcnRlc3RDb2x1bW5dID0gY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbc2hvcnRlc3RDb2x1bW5dICsgY29sdW1uV2lkdGggLyByYXRpbyhwaG90bykgKyBzcGFjaW5nICsgMiAqIHBhZGRpbmc7XG4gICAgICBtb2RlbFtzaG9ydGVzdENvbHVtbl0ucHVzaCh7IHBob3RvLCBpbmRleCB9KTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHVtbnMgfSkubWFwKCgpID0+IFtdKVxuICApO1xuICByZXR1cm4gY29sdW1uc01vZGVsLm1hcChcbiAgICAoY29sdW1uKSA9PiBjb2x1bW4ubWFwKCh7IHBob3RvLCBpbmRleCB9LCBwaG90b0luZGV4KSA9PiAoe1xuICAgICAgcGhvdG8sXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG8pLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgcGhvdG9JbmRleCxcbiAgICAgICAgcGhvdG9zQ291bnQ6IGNvbHVtbi5sZW5ndGhcbiAgICAgIH1cbiAgICB9KSlcbiAgKTtcbn1cbmZ1bmN0aW9uIE1hc29ucnlMYXlvdXQocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJlbmRlclBob3RvLFxuICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICBjb21wb25lbnRzUHJvcHM6IHsgaW1hZ2VQcm9wcywgY29sdW1uQ29udGFpbmVyUHJvcHMgfVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG1hc29ucnlMYXlvdXQgPSBjb21wdXRlTWFzb25yeUxheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9KTtcbiAgaWYgKCFtYXNvbnJ5TGF5b3V0KVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgbWFzb25yeUxheW91dC5tYXAoKGNvbHVtbiwgY29sdW1uSW5kZXgpID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgQ29sdW1uQ29udGFpbmVyUmVuZGVyZXIsXG4gICAge1xuICAgICAga2V5OiBgbWFzb25yeS1jb2x1bW4tJHtjb2x1bW5JbmRleH1gLFxuICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgIGNvbHVtbnNDb3VudDogbWFzb25yeUxheW91dC5sZW5ndGgsXG4gICAgICBjb2x1bW5JbmRleCxcbiAgICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICAgIGNvbHVtbkNvbnRhaW5lclByb3BzXG4gICAgfSxcbiAgICBjb2x1bW4ubWFwKCh7IHBob3RvLCBsYXlvdXQgfSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFBob3RvUmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGtleTogcGhvdG8ua2V5IHx8IHBob3RvLnNyYyxcbiAgICAgICAgcGhvdG8sXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgICAgcmVuZGVyUGhvdG8sXG4gICAgICAgIGltYWdlUHJvcHNcbiAgICAgIH1cbiAgICApKVxuICApKSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ29udGFpbmVyKHsgY29udGFpbmVyUHJvcHMsIGNoaWxkcmVuLCBjb250YWluZXJSZWYgfSkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogY29udGFpbmVyUmVmLCAuLi5jb250YWluZXJQcm9wcyB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBDb250YWluZXJSZW5kZXJlcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgbGF5b3V0LFxuICAgIHJlbmRlckNvbnRhaW5lcixcbiAgICBjaGlsZHJlbixcbiAgICBjb250YWluZXJSZWYsXG4gICAgY29udGFpbmVyUHJvcHM6IHsgc3R5bGUsIGNsYXNzTmFtZSwgLi4ucmVzdENvbnRhaW5lclByb3BzIH0gPSB7fVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbnRhaW5lclByb3BzID0ge1xuICAgIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LXBob3RvLWFsYnVtXCIsIGByZWFjdC1waG90by1hbGJ1bS0tJHtsYXlvdXR9YCwgY2xhc3NOYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4V3JhcDogXCJub3dyYXBcIixcbiAgICAgIGp1c3RpZnlDb250ZW50OiBcInNwYWNlLWJldHdlZW5cIixcbiAgICAgIGZsZXhEaXJlY3Rpb246IGxheW91dCA9PT0gXCJyb3dzXCIgPyBcImNvbHVtblwiIDogXCJyb3dcIixcbiAgICAgIC4uLnN0eWxlXG4gICAgfSxcbiAgICAuLi5yZXN0Q29udGFpbmVyUHJvcHNcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIChyZW5kZXJDb250YWluZXIgIT0gbnVsbCA/IHJlbmRlckNvbnRhaW5lciA6IGRlZmF1bHRSZW5kZXJDb250YWluZXIpKHtcbiAgICBjb250YWluZXJQcm9wcyxcbiAgICBjb250YWluZXJSZWYsXG4gICAgbGF5b3V0LFxuICAgIGNoaWxkcmVuXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHVzZUFycmF5KGFycmF5KSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihhcnJheSk7XG4gIGlmICghYXJyYXkgfHwgIXJlZi5jdXJyZW50IHx8IGFycmF5LmpvaW4oKSAhPT0gcmVmLmN1cnJlbnQuam9pbigpKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBhcnJheTtcbiAgfVxuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5mdW5jdGlvbiBjb250YWluZXJXaWR0aFJlZHVjZXIoc3RhdGUsIHsgbmV3Q29udGFpbmVyV2lkdGgsIG5ld1Njcm9sbGJhcldpZHRoIH0pIHtcbiAgY29uc3QgeyBjb250YWluZXJXaWR0aCwgc2Nyb2xsYmFyV2lkdGggfSA9IHN0YXRlO1xuICBpZiAoY29udGFpbmVyV2lkdGggIT09IHZvaWQgMCAmJiBzY3JvbGxiYXJXaWR0aCAhPT0gdm9pZCAwICYmIG5ld0NvbnRhaW5lcldpZHRoICE9PSB2b2lkIDAgJiYgbmV3U2Nyb2xsYmFyV2lkdGggIT09IHZvaWQgMCAmJiBuZXdDb250YWluZXJXaWR0aCA+IGNvbnRhaW5lcldpZHRoICYmIG5ld0NvbnRhaW5lcldpZHRoIC0gY29udGFpbmVyV2lkdGggPD0gMjAgJiYgbmV3U2Nyb2xsYmFyV2lkdGggPCBzY3JvbGxiYXJXaWR0aCkge1xuICAgIHJldHVybiB7IGNvbnRhaW5lcldpZHRoLCBzY3JvbGxiYXJXaWR0aDogbmV3U2Nyb2xsYmFyV2lkdGggfTtcbiAgfVxuICByZXR1cm4gY29udGFpbmVyV2lkdGggIT09IG5ld0NvbnRhaW5lcldpZHRoIHx8IHNjcm9sbGJhcldpZHRoICE9PSBuZXdTY3JvbGxiYXJXaWR0aCA/IHsgY29udGFpbmVyV2lkdGg6IG5ld0NvbnRhaW5lcldpZHRoLCBzY3JvbGxiYXJXaWR0aDogbmV3U2Nyb2xsYmFyV2lkdGggfSA6IHN0YXRlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNvbnRhaW5lcldpZHRoKGVsLCBicmVha3BvaW50czIpIHtcbiAgbGV0IHdpZHRoID0gZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLmNsaWVudFdpZHRoO1xuICBpZiAod2lkdGggIT09IHZvaWQgMCAmJiBicmVha3BvaW50czIgJiYgYnJlYWtwb2ludHMyLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4uYnJlYWtwb2ludHMyLmZpbHRlcigoeCkgPT4geCA+IDApXS5zb3J0KChhLCBiKSA9PiBiIC0gYSk7XG4gICAgc29ydGVkLnB1c2goTWF0aC5mbG9vcihzb3J0ZWRbc29ydGVkLmxlbmd0aCAtIDFdIC8gMikpO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHdpZHRoO1xuICAgIHdpZHRoID0gc29ydGVkLmZpbmQoKGJyZWFrcG9pbnQsIGluZGV4KSA9PiBicmVha3BvaW50IDw9IHRocmVzaG9sZCB8fCBpbmRleCA9PT0gc29ydGVkLmxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiB3aWR0aDtcbn1cbmZ1bmN0aW9uIHVzZUNvbnRhaW5lcldpZHRoKGJyZWFrcG9pbnRzMiwgZGVmYXVsdENvbnRhaW5lcldpZHRoKSB7XG4gIGNvbnN0IFt7IGNvbnRhaW5lcldpZHRoIH0sIGRpc3BhdGNoXSA9IFJlYWN0LnVzZVJlZHVjZXIoY29udGFpbmVyV2lkdGhSZWR1Y2VyLCB7XG4gICAgY29udGFpbmVyV2lkdGg6IGRlZmF1bHRDb250YWluZXJXaWR0aFxuICB9KTtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBvYnNlcnZlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBjb250YWluZXJSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAobm9kZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gb2JzZXJ2ZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBjb25zdCB1cGRhdGVXaWR0aCA9ICgpID0+IGRpc3BhdGNoKHtcbiAgICAgICAgbmV3Q29udGFpbmVyV2lkdGg6IHJlc29sdmVDb250YWluZXJXaWR0aChyZWYuY3VycmVudCwgYnJlYWtwb2ludHMyKSxcbiAgICAgICAgbmV3U2Nyb2xsYmFyV2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZVdpZHRoKCk7XG4gICAgICBpZiAobm9kZSAmJiB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBSZXNpemVPYnNlcnZlcih1cGRhdGVXaWR0aCk7XG4gICAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQub2JzZXJ2ZShub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFticmVha3BvaW50czJdXG4gICk7XG4gIHJldHVybiB7IGNvbnRhaW5lclJlZiwgY29udGFpbmVyV2lkdGggfTtcbn1cbmNvbnN0IGJyZWFrcG9pbnRzID0gT2JqZWN0LmZyZWV6ZShbMTIwMCwgNjAwLCAzMDAsIDBdKTtcbmZ1bmN0aW9uIHVud3JhcCh2YWx1ZSwgYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlKGFyZykgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHVud3JhcFBhcmFtZXRlcih2YWx1ZSwgY29udGFpbmVyV2lkdGgpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHVud3JhcCh2YWx1ZSwgY29udGFpbmVyV2lkdGgpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gc2VsZWN0UmVzcG9uc2l2ZVZhbHVlKHZhbHVlcywgY29udGFpbmVyV2lkdGgpIHtcbiAgY29uc3QgaW5kZXggPSBicmVha3BvaW50cy5maW5kSW5kZXgoKGJyZWFrcG9pbnQpID0+IGJyZWFrcG9pbnQgPD0gY29udGFpbmVyV2lkdGgpO1xuICByZXR1cm4gdW53cmFwKHZhbHVlc1tpbmRleCA+PSAwID8gaW5kZXggOiAwXSwgY29udGFpbmVyV2lkdGgpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIocGFyYW1ldGVyLCBjb250YWluZXJXaWR0aCwgdmFsdWVzLCBtaW5WYWx1ZSA9IDApIHtcbiAgY29uc3QgdmFsdWUgPSB1bndyYXBQYXJhbWV0ZXIocGFyYW1ldGVyLCBjb250YWluZXJXaWR0aCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWF4KHZhbHVlID09PSB2b2lkIDAgPyBzZWxlY3RSZXNwb25zaXZlVmFsdWUodmFsdWVzLCBjb250YWluZXJXaWR0aCkgOiB2YWx1ZSwgbWluVmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMYXlvdXRPcHRpb25zKHtcbiAgbGF5b3V0LFxuICBvbkNsaWNrLFxuICBjb250YWluZXJXaWR0aCxcbiAgdGFyZ2V0Um93SGVpZ2h0LFxuICByb3dDb25zdHJhaW50cyxcbiAgY29sdW1ucyxcbiAgc3BhY2luZyxcbiAgcGFkZGluZyxcbiAgc2l6ZXNcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBsYXlvdXQsXG4gICAgb25DbGljayxcbiAgICBjb250YWluZXJXaWR0aCxcbiAgICBjb2x1bW5zOiByZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlcihjb2x1bW5zLCBjb250YWluZXJXaWR0aCwgWzUsIDQsIDMsIDJdLCAxKSxcbiAgICBzcGFjaW5nOiByZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlcihzcGFjaW5nLCBjb250YWluZXJXaWR0aCwgWzIwLCAxNSwgMTAsIDVdKSxcbiAgICBwYWRkaW5nOiByZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlcihwYWRkaW5nLCBjb250YWluZXJXaWR0aCwgWzAsIDAsIDAsIDAsIDBdKSxcbiAgICB0YXJnZXRSb3dIZWlnaHQ6IHJlc29sdmVSZXNwb25zaXZlUGFyYW1ldGVyKHRhcmdldFJvd0hlaWdodCwgY29udGFpbmVyV2lkdGgsIFtcbiAgICAgICh3KSA9PiB3IC8gNSxcbiAgICAgICh3KSA9PiB3IC8gNCxcbiAgICAgICh3KSA9PiB3IC8gMyxcbiAgICAgICh3KSA9PiB3IC8gMlxuICAgIF0pLFxuICAgIHJvd0NvbnN0cmFpbnRzOiB1bndyYXBQYXJhbWV0ZXIocm93Q29uc3RyYWludHMsIGNvbnRhaW5lcldpZHRoKSxcbiAgICBzaXplc1xuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHNQcm9wcyhwcm9wcywgY29udGFpbmVyV2lkdGgsIGxheW91dE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGNvbXBvbmVudHNQcm9wczogY29tcG9uZW50c1Byb3BzUHJvcCB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbXBvbmVudHNQcm9wcyA9IHVud3JhcChjb21wb25lbnRzUHJvcHNQcm9wLCBjb250YWluZXJXaWR0aCkgfHwge307XG4gIGlmIChsYXlvdXRPcHRpb25zKSB7XG4gICAgY29uc3QgeyBsYXlvdXQsIHNwYWNpbmcsIHBhZGRpbmcsIHJvd0NvbnN0cmFpbnRzIH0gPSBsYXlvdXRPcHRpb25zO1xuICAgIGlmIChsYXlvdXQgPT09IFwicm93c1wiKSB7XG4gICAgICBjb25zdCB7IHNpbmdsZVJvd01heEhlaWdodCB9ID0gcm93Q29uc3RyYWludHMgfHwge307XG4gICAgICBpZiAoc2luZ2xlUm93TWF4SGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gTWF0aC5mbG9vcihcbiAgICAgICAgICBwaG90b3MucmVkdWNlKFxuICAgICAgICAgICAgKGFjYywgeyB3aWR0aCwgaGVpZ2h0IH0pID0+IGFjYyArIHdpZHRoIC8gaGVpZ2h0ICogc2luZ2xlUm93TWF4SGVpZ2h0IC0gMiAqIHBhZGRpbmcsXG4gICAgICAgICAgICBwYWRkaW5nICogcGhvdG9zLmxlbmd0aCAqIDIgKyBzcGFjaW5nICogKHBob3Rvcy5sZW5ndGggLSAxKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1heFdpZHRoID4gMCkge1xuICAgICAgICAgIGNvbXBvbmVudHNQcm9wcy5jb250YWluZXJQcm9wcyA9IGNvbXBvbmVudHNQcm9wcy5jb250YWluZXJQcm9wcyB8fCB7fTtcbiAgICAgICAgICBjb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHMuc3R5bGUgPSB7IG1heFdpZHRoLCAuLi5jb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHMuc3R5bGUgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1Byb3BzO1xufVxuZnVuY3Rpb24gcmVuZGVyTGF5b3V0KHByb3BzLCBjb21wb25lbnRzUHJvcHMsIGxheW91dE9wdGlvbnMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGxheW91dCwgcmVuZGVyUGhvdG8sIHJlbmRlclJvd0NvbnRhaW5lciwgcmVuZGVyQ29sdW1uQ29udGFpbmVyIH0gPSBwcm9wcztcbiAgY29uc3QgY29tbW9uTGF5b3V0UHJvcHMgPSB7IHBob3RvcywgcmVuZGVyUGhvdG8sIGNvbXBvbmVudHNQcm9wcyB9O1xuICBpZiAobGF5b3V0ID09PSBcInJvd3NcIikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgUm93c0xheW91dCxcbiAgICAgIHtcbiAgICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgICAgcmVuZGVyUm93Q29udGFpbmVyLFxuICAgICAgICAuLi5jb21tb25MYXlvdXRQcm9wc1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gXCJjb2x1bW5zXCIpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIENvbHVtbnNMYXlvdXQsXG4gICAgICB7XG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICAgICAgLi4uY29tbW9uTGF5b3V0UHJvcHNcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIE1hc29ucnlMYXlvdXQsXG4gICAge1xuICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICAgIC4uLmNvbW1vbkxheW91dFByb3BzXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gUGhvdG9BbGJ1bShwcm9wcykge1xuICBjb25zdCB7IHBob3RvcywgbGF5b3V0LCByZW5kZXJDb250YWluZXIsIGRlZmF1bHRDb250YWluZXJXaWR0aCwgYnJlYWtwb2ludHM6IGJyZWFrcG9pbnRzMiB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgY29udGFpbmVyUmVmLCBjb250YWluZXJXaWR0aCB9ID0gdXNlQ29udGFpbmVyV2lkdGgodXNlQXJyYXkoYnJlYWtwb2ludHMyKSwgZGVmYXVsdENvbnRhaW5lcldpZHRoKTtcbiAgaWYgKCFsYXlvdXQgfHwgIVtcInJvd3NcIiwgXCJjb2x1bW5zXCIsIFwibWFzb25yeVwiXS5pbmNsdWRlcyhsYXlvdXQpIHx8ICFBcnJheS5pc0FycmF5KHBob3RvcykpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGxheW91dE9wdGlvbnMgPSBjb250YWluZXJXaWR0aCA/IHJlc29sdmVMYXlvdXRPcHRpb25zKHsgY29udGFpbmVyV2lkdGgsIC4uLnByb3BzIH0pIDogdm9pZCAwO1xuICBjb25zdCBjb21wb25lbnRzUHJvcHMgPSByZXNvbHZlQ29tcG9uZW50c1Byb3BzKHByb3BzLCBjb250YWluZXJXaWR0aCwgbGF5b3V0T3B0aW9ucyk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIENvbnRhaW5lclJlbmRlcmVyLFxuICAgIHtcbiAgICAgIGxheW91dCxcbiAgICAgIGNvbnRhaW5lclJlZixcbiAgICAgIHJlbmRlckNvbnRhaW5lcixcbiAgICAgIGNvbnRhaW5lclByb3BzOiBjb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHNcbiAgICB9LFxuICAgIGxheW91dE9wdGlvbnMgJiYgcmVuZGVyTGF5b3V0KHByb3BzLCBjb21wb25lbnRzUHJvcHMsIGxheW91dE9wdGlvbnMpXG4gICk7XG59XG5leHBvcnQge1xuICBQaG90b0FsYnVtLFxuICBQaG90b0FsYnVtIGFzIGRlZmF1bHQsXG4gIGNvbXB1dGVDb2x1bW5zTGF5b3V0IGFzIHVuc3RhYmxlX2NvbXB1dGVDb2x1bW5zTGF5b3V0LFxuICBjb21wdXRlTWFzb25yeUxheW91dCBhcyB1bnN0YWJsZV9jb21wdXRlTWFzb25yeUxheW91dCxcbiAgY29tcHV0ZVJvd3NMYXlvdXQgYXMgdW5zdGFibGVfY29tcHV0ZVJvd3NMYXlvdXRcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJyYXRpbyIsIndpZHRoIiwiaGVpZ2h0Iiwicm91bmQiLCJ2YWx1ZSIsImRlY2ltYWxzIiwiZmFjdG9yIiwiTWF0aCIsIk51bWJlciIsIkVQU0lMT04iLCJyYW5raW5nRnVuY3Rpb25Db21wYXJhdG9yIiwicmFuayIsImEiLCJiIiwiTWluSGVhcCIsImNvbnN0cnVjdG9yIiwiY29tcGFyYXRvciIsImhlYXAiLCJuIiwiZ3JlYXRlciIsImkiLCJqIiwic3dhcCIsInRlbXAiLCJzd2ltIiwiayIsImsyIiwiZmxvb3IiLCJzaW5rIiwicHVzaCIsImVsZW1lbnQiLCJwb3AiLCJtYXgiLCJzaXplIiwiYnVpbGRQcmVjZWRlbnRzTWFwIiwiZ3JhcGgiLCJzdGFydE5vZGUiLCJlbmROb2RlIiwicHJlY2VkZW50c01hcCIsIk1hcCIsInZpc2l0ZWQiLCJTZXQiLCJzdG9yZWRTaG9ydGVzdFBhdGhzIiwic2V0IiwicXVldWUiLCJlbCIsIndlaWdodCIsImlkIiwiaGFzIiwibmVpZ2hib3JpbmdOb2RlcyIsImFkZCIsImZvckVhY2giLCJuZWlnaGJvcldlaWdodCIsIm5laWdoYm9yIiwibmV3V2VpZ2h0IiwiY3VycmVudElkIiwiZ2V0IiwiY3VycmVudFdlaWdodCIsImdldFBhdGhGcm9tUHJlY2VkZW50c01hcCIsIm5vZGVzIiwibm9kZSIsInJldmVyc2UiLCJmaW5kU2hvcnRlc3RQYXRoIiwiZmluZElkZWFsTm9kZVNlYXJjaCIsInBob3RvcyIsInRhcmdldFJvd0hlaWdodCIsImNvbnRhaW5lcldpZHRoIiwibWluUmF0aW8iLCJyZWR1Y2UiLCJhY2MiLCJwaG90byIsIm1pbiIsIk1BWF9WQUxVRSIsImdldENvbW1vbkhlaWdodCIsInJvdyIsInNwYWNpbmciLCJwYWRkaW5nIiwicm93V2lkdGgiLCJsZW5ndGgiLCJ0b3RhbEFzcGVjdFJhdGlvIiwiY29zdCIsInNsaWNlIiwiY29tbW9uSGVpZ2h0IiwibWFrZUdldFJvd05laWdoYm9ycyIsImxheW91dE9wdGlvbnMiLCJsaW1pdE5vZGVTZWFyY2giLCJyb3dDb25zdHJhaW50cyIsIl9hIiwiX2IiLCJyZXN1bHRzIiwic3RhcnRPZmZzZXQiLCJtaW5QaG90b3MiLCJlbmRPZmZzZXQiLCJtYXhQaG90b3MiLCJJbmZpbml0eSIsImN1cnJlbnRDb3N0IiwiY29tcHV0ZVJvd3NMYXlvdXQiLCJnZXROZWlnaGJvcnMiLCJwYXRoIiwibGF5b3V0IiwibWFwIiwiaW5kZXgiLCJwaG90b0luZGV4IiwicGhvdG9zQ291bnQiLCJjbHN4IiwiY2xhc3NlcyIsImZpbHRlciIsImNscyIsIkJvb2xlYW4iLCJqb2luIiwiY2FsY1dpZHRoIiwiYmFzZSIsImdhcHMiLCJjc3NQaG90b1dpZHRoIiwiY2FsY3VsYXRlU2l6ZXNWYWx1ZSIsIm1hdGNoIiwic3JjU2V0QW5kU2l6ZXMiLCJzcmNTZXQiLCJzaXplcyIsImltYWdlcyIsImNvbmNhdCIsImZpbmQiLCJzcmMiLCJzb3J0IiwiZmlyc3QiLCJzZWNvbmQiLCJpbWFnZSIsInZpZXdwb3J0IiwiY2VpbCIsIlBob3RvUmVuZGVyZXIiLCJwcm9wcyIsImltYWdlUHJvcHMiLCJzdHlsZSIsImNsYXNzTmFtZSIsInJlc3RJbWFnZVByb3BzIiwicmVuZGVyUGhvdG8iLCJvbkNsaWNrIiwiaW1hZ2VTdHlsZSIsImRpc3BsYXkiLCJib3hTaXppbmciLCJhc3BlY3RSYXRpbyIsIm1hcmdpbkJvdHRvbSIsImN1cnNvciIsImhhbmRsZUNsaWNrIiwiZXZlbnQiLCJhbHQiLCJ0aXRsZSIsImxvYWRpbmciLCJkZWNvZGluZyIsInJlbmRlckRlZmF1bHRQaG90byIsIm9wdGlvbnMiLCJ1bndyYXBwZWRTdHlsZSIsInJlc3QiLCJjcmVhdGVFbGVtZW50Iiwid3JhcHBlZCIsIndyYXBwZXJTdHlsZSIsIkZyYWdtZW50IiwiZGVmYXVsdFJlbmRlclJvd0NvbnRhaW5lciIsInJvd0NvbnRhaW5lclByb3BzIiwiY2hpbGRyZW4iLCJSb3dDb250YWluZXJSZW5kZXJlciIsInJvd0luZGV4Iiwicm93c0NvdW50IiwicmVuZGVyUm93Q29udGFpbmVyIiwicmVzdFJvd0NvbnRhaW5lclByb3BzIiwiZmxleERpcmVjdGlvbiIsImZsZXhXcmFwIiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwiUm93c0xheW91dCIsImNvbXBvbmVudHNQcm9wcyIsInJvd3NMYXlvdXQiLCJrZXkiLCJjb21wdXRlU2hvcnRlc3RQYXRoIiwicGF0aExlbmd0aCIsIm1hdHJpeCIsImN1cnJlbnRRdWV1ZSIsImtleXMiLCJjbGVhciIsImFjY3VtdWxhdGVkV2VpZ2h0IiwicGF0aHMiLCJuZXh0UGF0aCIsInJlY29uc3RydWN0U2hvcnRlc3RQYXRoIiwiZmluZFNob3J0ZXN0UGF0aExlbmd0aE4iLCJtYWtlR2V0Q29sdW1uTmVpZ2hib3JzIiwidGFyZ2V0Q29sdW1uV2lkdGgiLCJ0YXJnZXRDb2x1bW5IZWlnaHQiLCJjdXRPZmZIZWlnaHQiLCJidWlsZENvbHVtbnNNb2RlbCIsImNvbHVtbnNHYXBzIiwiY29sdW1uc1JhdGlvcyIsImNvbHVtbnNNb2RlbCIsInRvdGFsUmF0aW8iLCJ0b3RhbCIsImNvbHVtblJhdGlvIiwiY29sdW1uIiwidG90YWxBZGp1c3RlZEdhcHMiLCJjb2x1bW5XaWR0aCIsImNvbXB1dGVDb2x1bW5zTW9kZWwiLCJjb2x1bW5zIiwiYXZlcmFnZVJhdGlvIiwiY29sdW1uc01vZGVsMiIsIkFycmF5IiwiZnJvbSIsIl8iLCJjb21wdXRlTGF5b3V0IiwiZmluZEluZGV4IiwiY29sdW1uTW9kZWwiLCJjb21wdXRlQ29sdW1uc0xheW91dCIsImRlZmF1bHRSZW5kZXJDb2x1bW5Db250YWluZXIiLCJjb2x1bW5Db250YWluZXJQcm9wcyIsImNzc0NvbHVtbldpZHRoIiwiY29sdW1uSW5kZXgiLCJjb2x1bW5zQ291bnQiLCJyYXRpbzIiLCJDb2x1bW5Db250YWluZXJSZW5kZXJlciIsInJlbmRlckNvbHVtbkNvbnRhaW5lciIsInJlc3RDb2x1bW5Db250YWluZXJQcm9wcyIsIkNvbHVtbnNMYXlvdXQiLCJjb2x1bW5zTGF5b3V0IiwiY29tcHV0ZU1hc29ucnlMYXlvdXQiLCJjb2x1bW5zQ3VycmVudFRvcFBvc2l0aW9ucyIsIm1vZGVsIiwic2hvcnRlc3RDb2x1bW4iLCJjdXJyZW50U2hvcnRlc3RDb2x1bW4iLCJpdGVtIiwiTWFzb25yeUxheW91dCIsIm1hc29ucnlMYXlvdXQiLCJkZWZhdWx0UmVuZGVyQ29udGFpbmVyIiwiY29udGFpbmVyUHJvcHMiLCJjb250YWluZXJSZWYiLCJyZWYiLCJDb250YWluZXJSZW5kZXJlciIsInJlbmRlckNvbnRhaW5lciIsInJlc3RDb250YWluZXJQcm9wcyIsInVzZUFycmF5IiwiYXJyYXkiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29udGFpbmVyV2lkdGhSZWR1Y2VyIiwic3RhdGUiLCJuZXdDb250YWluZXJXaWR0aCIsIm5ld1Njcm9sbGJhcldpZHRoIiwic2Nyb2xsYmFyV2lkdGgiLCJyZXNvbHZlQ29udGFpbmVyV2lkdGgiLCJicmVha3BvaW50czIiLCJjbGllbnRXaWR0aCIsInNvcnRlZCIsIngiLCJ0aHJlc2hvbGQiLCJicmVha3BvaW50IiwidXNlQ29udGFpbmVyV2lkdGgiLCJkZWZhdWx0Q29udGFpbmVyV2lkdGgiLCJkaXNwYXRjaCIsInVzZVJlZHVjZXIiLCJvYnNlcnZlclJlZiIsInVzZUNhbGxiYWNrIiwiZGlzY29ubmVjdCIsInVwZGF0ZVdpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYnJlYWtwb2ludHMiLCJPYmplY3QiLCJmcmVlemUiLCJ1bndyYXAiLCJhcmciLCJ1bndyYXBQYXJhbWV0ZXIiLCJzZWxlY3RSZXNwb25zaXZlVmFsdWUiLCJ2YWx1ZXMiLCJyZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlciIsInBhcmFtZXRlciIsIm1pblZhbHVlIiwicmVzb2x2ZUxheW91dE9wdGlvbnMiLCJ3IiwicmVzb2x2ZUNvbXBvbmVudHNQcm9wcyIsImNvbXBvbmVudHNQcm9wc1Byb3AiLCJzaW5nbGVSb3dNYXhIZWlnaHQiLCJtYXhXaWR0aCIsInJlbmRlckxheW91dCIsImNvbW1vbkxheW91dFByb3BzIiwiUGhvdG9BbGJ1bSIsImluY2x1ZGVzIiwiaXNBcnJheSIsImRlZmF1bHQiLCJ1bnN0YWJsZV9jb21wdXRlQ29sdW1uc0xheW91dCIsInVuc3RhYmxlX2NvbXB1dGVNYXNvbnJ5TGF5b3V0IiwidW5zdGFibGVfY29tcHV0ZVJvd3NMYXlvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-photo-album/dist/index.mjs\n");

/***/ })

};
;