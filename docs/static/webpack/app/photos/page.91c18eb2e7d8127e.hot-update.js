/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/photos/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fpedro%2FDocuments%2FOther%2FWeb%2Fpedros-website%2Fnode_modules%2Freact-photo-album%2Fdist%2Findex.mjs%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fpedro%2FDocuments%2FOther%2FWeb%2Fpedros-website%2Fnode_modules%2Freact-photo-album%2Fdist%2Findex.mjs%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/react-photo-album/dist/index.mjs */ \"(app-pages-browser)/./node_modules/react-photo-album/dist/index.mjs\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZwZWRybyUyRkRvY3VtZW50cyUyRk90aGVyJTJGV2ViJTJGcGVkcm9zLXdlYnNpdGUlMkZub2RlX21vZHVsZXMlMkZyZWFjdC1waG90by1hbGJ1bSUyRmRpc3QlMkZpbmRleC5tanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsd05BQStKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZGRkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcImRlZmF1bHRcIl0gKi8gXCIvVXNlcnMvcGVkcm8vRG9jdW1lbnRzL090aGVyL1dlYi9wZWRyb3Mtd2Vic2l0ZS9ub2RlX21vZHVsZXMvcmVhY3QtcGhvdG8tYWxidW0vZGlzdC9pbmRleC5tanNcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fpedro%2FDocuments%2FOther%2FWeb%2Fpedros-website%2Fnode_modules%2Freact-photo-album%2Fdist%2Findex.mjs%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-photo-album/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-photo-album/dist/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhotoAlbum: function() { return /* binding */ PhotoAlbum; },\n/* harmony export */   \"default\": function() { return /* binding */ PhotoAlbum; },\n/* harmony export */   unstable_computeColumnsLayout: function() { return /* binding */ computeColumnsLayout; },\n/* harmony export */   unstable_computeMasonryLayout: function() { return /* binding */ computeMasonryLayout; },\n/* harmony export */   unstable_computeRowsLayout: function() { return /* binding */ computeRowsLayout; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* __next_internal_client_entry_do_not_use__ PhotoAlbum,default,unstable_computeColumnsLayout,unstable_computeMasonryLayout,unstable_computeRowsLayout auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\nfunction ratio(param) {\n    let { width, height } = param;\n    return width / height;\n}\nfunction round(value) {\n    let decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    const factor = 10 ** decimals;\n    return Math.round((value + Number.EPSILON) * factor) / factor;\n}\nfunction rankingFunctionComparator(rank) {\n    return (a, b)=>rank(b) - rank(a);\n}\nclass MinHeap {\n    greater(i, j) {\n        return this.comparator(this.heap[i], this.heap[j]) < 0;\n    }\n    swap(i, j) {\n        const temp = this.heap[i];\n        this.heap[i] = this.heap[j];\n        this.heap[j] = temp;\n    }\n    swim(i) {\n        let k = i;\n        let k2 = Math.floor(k / 2);\n        while(k > 1 && this.greater(k2, k)){\n            this.swap(k2, k);\n            k = k2;\n            k2 = Math.floor(k / 2);\n        }\n    }\n    sink(i) {\n        let k = i;\n        let k2 = k * 2;\n        while(k2 <= this.n){\n            if (k2 < this.n && this.greater(k2, k2 + 1)) k2 += 1;\n            if (!this.greater(k, k2)) break;\n            this.swap(k, k2);\n            k = k2;\n            k2 = k * 2;\n        }\n    }\n    push(element) {\n        this.n += 1;\n        this.heap[this.n] = element;\n        this.swim(this.n);\n    }\n    pop() {\n        if (this.n === 0) return void 0;\n        this.swap(1, this.n);\n        this.n -= 1;\n        const max = this.heap.pop();\n        this.sink(1);\n        return max;\n    }\n    size() {\n        return this.n;\n    }\n    constructor(comparator){\n        this.comparator = comparator;\n        this.heap = [];\n        this.n = 0;\n    }\n}\nfunction buildPrecedentsMap(graph, startNode, endNode) {\n    const precedentsMap = /* @__PURE__ */ new Map();\n    const visited = /* @__PURE__ */ new Set();\n    const storedShortestPaths = /* @__PURE__ */ new Map();\n    storedShortestPaths.set(startNode, 0);\n    const queue = new MinHeap(rankingFunctionComparator((el)=>el.weight));\n    queue.push({\n        id: startNode,\n        weight: 0\n    });\n    while(queue.size() > 0){\n        const { id, weight } = queue.pop();\n        if (!visited.has(id)) {\n            const neighboringNodes = graph(id);\n            visited.add(id);\n            neighboringNodes.forEach((neighborWeight, neighbor)=>{\n                const newWeight = weight + neighborWeight;\n                const currentId = precedentsMap.get(neighbor);\n                const currentWeight = storedShortestPaths.get(neighbor);\n                if (currentWeight === void 0 || currentWeight > newWeight && (currentWeight / newWeight > 1.005 || currentId !== void 0 && currentId < id)) {\n                    storedShortestPaths.set(neighbor, newWeight);\n                    queue.push({\n                        id: neighbor,\n                        weight: newWeight\n                    });\n                    precedentsMap.set(neighbor, id);\n                }\n            });\n        }\n    }\n    return storedShortestPaths.has(endNode) ? precedentsMap : void 0;\n}\nfunction getPathFromPrecedentsMap(precedentsMap, endNode) {\n    const nodes = [];\n    for(let node = endNode; node !== void 0; node = precedentsMap.get(node)){\n        nodes.push(node);\n    }\n    return nodes.reverse();\n}\nfunction findShortestPath(graph, startNode, endNode) {\n    const precedentsMap = buildPrecedentsMap(graph, startNode, endNode);\n    return precedentsMap ? getPathFromPrecedentsMap(precedentsMap, endNode) : void 0;\n}\nfunction findIdealNodeSearch(param) {\n    let { photos, targetRowHeight, containerWidth } = param;\n    const minRatio = photos.reduce((acc, photo)=>Math.min(ratio(photo), acc), Number.MAX_VALUE);\n    return round(containerWidth / targetRowHeight / minRatio) + 2;\n}\nfunction getCommonHeight(row, containerWidth, spacing, padding) {\n    const rowWidth = containerWidth - (row.length - 1) * spacing - 2 * padding * row.length;\n    const totalAspectRatio = row.reduce((acc, photo)=>acc + ratio(photo), 0);\n    return rowWidth / totalAspectRatio;\n}\nfunction cost(photos, i, j, width, targetRowHeight, spacing, padding) {\n    const row = photos.slice(i, j);\n    const commonHeight = getCommonHeight(row, width, spacing, padding);\n    return commonHeight > 0 ? (commonHeight - targetRowHeight) ** 2 * row.length : void 0;\n}\nfunction makeGetRowNeighbors(param) {\n    let { photos, layoutOptions, targetRowHeight, limitNodeSearch, rowConstraints } = param;\n    return (node)=>{\n        var _a, _b;\n        const { containerWidth, spacing, padding } = layoutOptions;\n        const results = /* @__PURE__ */ new Map();\n        results.set(node, 0);\n        const startOffset = (_a = rowConstraints == null ? void 0 : rowConstraints.minPhotos) != null ? _a : 1;\n        const endOffset = Math.min(limitNodeSearch, (_b = rowConstraints == null ? void 0 : rowConstraints.maxPhotos) != null ? _b : Infinity);\n        for(let i = node + startOffset; i < photos.length + 1; i += 1){\n            if (i - node > endOffset) break;\n            const currentCost = cost(photos, node, i, containerWidth, targetRowHeight, spacing, padding);\n            if (currentCost === void 0) break;\n            results.set(i, currentCost);\n        }\n        return results;\n    };\n}\nfunction computeRowsLayout(param) {\n    let { photos, layoutOptions } = param;\n    const { spacing, padding, containerWidth, targetRowHeight, rowConstraints } = layoutOptions;\n    const limitNodeSearch = findIdealNodeSearch({\n        photos,\n        containerWidth,\n        targetRowHeight\n    });\n    const getNeighbors = makeGetRowNeighbors({\n        photos,\n        layoutOptions,\n        targetRowHeight,\n        limitNodeSearch,\n        rowConstraints\n    });\n    const path = findShortestPath(getNeighbors, 0, photos.length);\n    if (path === void 0) return void 0;\n    const layout = [];\n    for(let i = 1; i < path.length; i += 1){\n        const row = photos.map((photo, index)=>({\n                photo,\n                index\n            })).slice(path[i - 1], path[i]);\n        const height = getCommonHeight(row.map((param)=>{\n            let { photo } = param;\n            return photo;\n        }), containerWidth, spacing, padding);\n        layout.push(row.map((param, photoIndex)=>{\n            let { photo, index } = param;\n            return {\n                photo,\n                layout: {\n                    height,\n                    width: height * ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: row.length\n                }\n            };\n        }));\n    }\n    return layout;\n}\nfunction clsx() {\n    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){\n        classes[_key] = arguments[_key];\n    }\n    return [\n        ...classes\n    ].filter((cls)=>Boolean(cls)).join(\" \");\n}\nfunction calcWidth(base, param, param1) {\n    let { width, photosCount } = param, { spacing, padding, containerWidth } = param1;\n    const gaps = spacing * (photosCount - 1) + 2 * padding * photosCount;\n    return \"calc((\".concat(base, \" - \").concat(gaps, \"px) / \").concat(round((containerWidth - gaps) / width, 5), \")\");\n}\nfunction cssPhotoWidth(layout, layoutOptions) {\n    return layoutOptions.layout !== \"rows\" ? \"calc(100% - \".concat(2 * layoutOptions.padding, \"px)\") : calcWidth(\"100%\", layout, layoutOptions);\n}\nfunction calculateSizesValue(size, layout, layoutOptions) {\n    var _a, _b;\n    return calcWidth((_b = (_a = size.match(/^\\s*calc\\((.*)\\)\\s*$/)) == null ? void 0 : _a[1]) != null ? _b : size, layout, layoutOptions);\n}\nfunction srcSetAndSizes(photo, layout, layoutOptions) {\n    let srcSet;\n    let sizes;\n    const images = photo.srcSet || photo.images;\n    if (images && images.length > 0) {\n        srcSet = images.concat(!images.find((param)=>{\n            let { width } = param;\n            return width === photo.width;\n        }) ? [\n            {\n                src: photo.src,\n                width: photo.width,\n                height: photo.height\n            }\n        ] : []).sort((first, second)=>first.width - second.width).map((image)=>\"\".concat(image.src, \" \").concat(image.width, \"w\")).join(\", \");\n    }\n    if (layoutOptions.sizes) {\n        sizes = (layoutOptions.sizes.sizes || []).map((param)=>{\n            let { viewport, size } = param;\n            return \"\".concat(viewport, \" \").concat(calculateSizesValue(size, layout, layoutOptions));\n        }).concat(calculateSizesValue(layoutOptions.sizes.size, layout, layoutOptions)).join(\", \");\n    } else if (srcSet) {\n        sizes = \"\".concat(Math.ceil(layout.width / layoutOptions.containerWidth * 100), \"vw\");\n    }\n    return {\n        srcSet,\n        sizes\n    };\n}\nfunction PhotoRenderer(props) {\n    var _a, _b;\n    const { photo, layout, layoutOptions, imageProps: { style, className, ...restImageProps } = {}, renderPhoto } = props;\n    const { onClick } = layoutOptions;\n    const imageStyle = {\n        display: \"block\",\n        boxSizing: \"content-box\",\n        width: cssPhotoWidth(layout, layoutOptions),\n        height: \"auto\",\n        aspectRatio: \"\".concat(photo.width, \" / \").concat(photo.height),\n        ...layoutOptions.padding ? {\n            padding: \"\".concat(layoutOptions.padding, \"px\")\n        } : null,\n        ...(layoutOptions.layout === \"columns\" || layoutOptions.layout === \"masonry\") && layout.photoIndex < layout.photosCount - 1 ? {\n            marginBottom: \"\".concat(layoutOptions.spacing, \"px\")\n        } : null,\n        ...onClick ? {\n            cursor: \"pointer\"\n        } : null,\n        ...style\n    };\n    const handleClick = onClick ? (event)=>{\n        onClick({\n            event,\n            photo,\n            index: layout.index\n        });\n    } : void 0;\n    const imageProps = {\n        src: photo.src,\n        alt: (_a = photo.alt) != null ? _a : \"\",\n        title: photo.title,\n        onClick: handleClick,\n        style: imageStyle,\n        className: clsx(\"react-photo-album--photo\", className),\n        loading: \"lazy\",\n        decoding: \"async\",\n        ...srcSetAndSizes(photo, layout, layoutOptions),\n        ...restImageProps\n    };\n    const renderDefaultPhoto = (options)=>{\n        const { src, alt, srcSet, sizes, style: unwrappedStyle, ...rest } = imageProps;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n            alt,\n            ...srcSet ? {\n                srcSet,\n                sizes\n            } : null,\n            src,\n            style: (options == null ? void 0 : options.wrapped) ? {\n                display: \"block\",\n                width: \"100%\",\n                height: \"100%\"\n            } : unwrappedStyle,\n            ...rest\n        });\n    };\n    const wrapperStyle = ((param)=>{\n        let { display, boxSizing, width, aspectRatio, padding, marginBottom, cursor } = param;\n        return {\n            display,\n            boxSizing,\n            width,\n            aspectRatio,\n            padding,\n            marginBottom,\n            cursor\n        };\n    })(imageStyle);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (_b = renderPhoto == null ? void 0 : renderPhoto({\n        photo,\n        layout,\n        layoutOptions,\n        imageProps,\n        renderDefaultPhoto,\n        wrapperStyle\n    })) != null ? _b : renderDefaultPhoto());\n}\n_c = PhotoRenderer;\nfunction defaultRenderRowContainer(param) {\n    let { rowContainerProps, children } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...rowContainerProps\n    }, children);\n}\nfunction RowContainerRenderer(props) {\n    const { layoutOptions, rowIndex, rowsCount, renderRowContainer, rowContainerProps: { style, className, ...restRowContainerProps } = {}, children } = props;\n    const rowContainerProps = {\n        className: clsx(\"react-photo-album--row\", className),\n        style: {\n            display: \"flex\",\n            flexDirection: \"row\",\n            flexWrap: \"nowrap\",\n            alignItems: \"flex-start\",\n            justifyContent: \"space-between\",\n            ...rowIndex < rowsCount - 1 ? {\n                marginBottom: \"\".concat(layoutOptions.spacing, \"px\")\n            } : null,\n            ...style\n        },\n        ...restRowContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderRowContainer != null ? renderRowContainer : defaultRenderRowContainer)({\n        layoutOptions,\n        rowIndex,\n        rowsCount,\n        rowContainerProps,\n        children\n    }));\n}\n_c1 = RowContainerRenderer;\nfunction RowsLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderRowContainer, componentsProps: { imageProps, rowContainerProps } } = props;\n    const rowsLayout = computeRowsLayout({\n        photos,\n        layoutOptions\n    });\n    if (!rowsLayout) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, rowsLayout.map((row, rowIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowContainerRenderer, {\n            key: \"row-\".concat(rowIndex),\n            layoutOptions,\n            rowIndex,\n            rowsCount: rowsLayout.length,\n            renderRowContainer,\n            rowContainerProps\n        }, row.map((param)=>{\n            let { photo, layout } = param;\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            });\n        }))));\n}\n_c2 = RowsLayout;\nfunction computeShortestPath(graph, pathLength, startNode, endNode) {\n    const matrix = /* @__PURE__ */ new Map();\n    const queue = /* @__PURE__ */ new Set();\n    queue.add(startNode);\n    for(let length = 0; length < pathLength; length += 1){\n        const currentQueue = [\n            ...queue.keys()\n        ];\n        queue.clear();\n        currentQueue.forEach((node)=>{\n            const accumulatedWeight = length > 0 ? matrix.get(node)[length].weight : 0;\n            graph(node).forEach((param)=>{\n                let { neighbor, weight } = param;\n                let paths = matrix.get(neighbor);\n                if (!paths) {\n                    paths = [];\n                    matrix.set(neighbor, paths);\n                }\n                const newWeight = accumulatedWeight + weight;\n                const nextPath = paths[length + 1];\n                if (!nextPath || nextPath.weight > newWeight && (nextPath.weight / newWeight > 1.0001 || node < nextPath.node)) {\n                    paths[length + 1] = {\n                        node,\n                        weight: newWeight\n                    };\n                }\n                if (length < pathLength - 1 && neighbor !== endNode) {\n                    queue.add(neighbor);\n                }\n            });\n        });\n    }\n    return matrix;\n}\nfunction reconstructShortestPath(matrix, pathLength, endNode) {\n    const path = [\n        endNode\n    ];\n    for(let node = endNode, length = pathLength; length > 0; length -= 1){\n        node = matrix.get(node)[length].node;\n        path.push(node);\n    }\n    return path.reverse();\n}\nfunction findShortestPathLengthN(graph, pathLength, startNode, endNode) {\n    return reconstructShortestPath(computeShortestPath(graph, pathLength, startNode, endNode), pathLength, endNode);\n}\nfunction makeGetColumnNeighbors(param) {\n    let { photos, spacing, padding, targetColumnWidth, targetColumnHeight } = param;\n    return (node)=>{\n        const results = [];\n        const cutOffHeight = targetColumnHeight * 1.5;\n        let height = targetColumnWidth / ratio(photos[node]) + 2 * padding;\n        for(let i = node + 1; i < photos.length + 1; i += 1){\n            results.push({\n                neighbor: i,\n                weight: (targetColumnHeight - height) ** 2\n            });\n            if (height > cutOffHeight || i === photos.length) {\n                break;\n            }\n            height += targetColumnWidth / ratio(photos[i]) + spacing + 2 * padding;\n        }\n        return results;\n    };\n}\nfunction buildColumnsModel(param) {\n    let { path, photos, containerWidth, columnsGaps, columnsRatios, spacing, padding } = param;\n    const columnsModel = [];\n    const totalRatio = columnsRatios.reduce((total, columnRatio)=>total + columnRatio, 0);\n    for(let i = 0; i < path.length - 1; i += 1){\n        const column = photos.map((photo, index)=>({\n                photo,\n                index\n            })).slice(path[i], path[i + 1]);\n        const totalAdjustedGaps = columnsRatios.reduce((total, columnRatio, index)=>total + (columnsGaps[i] - columnsGaps[index]) * columnRatio, 0);\n        const columnWidth = (containerWidth - (path.length - 2) * spacing - 2 * (path.length - 1) * padding - totalAdjustedGaps) * columnsRatios[i] / totalRatio;\n        columnsModel.push(column.map((param, photoIndex)=>{\n            let { photo, index } = param;\n            return {\n                photo,\n                layout: {\n                    width: columnWidth,\n                    height: columnWidth / ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: column.length\n                }\n            };\n        }));\n    }\n    return columnsModel;\n}\nfunction computeColumnsModel(param) {\n    let { photos, layoutOptions, targetColumnWidth } = param;\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const columnsGaps = [];\n    const columnsRatios = [];\n    if (photos.length <= columns) {\n        const averageRatio = photos.length > 0 ? photos.reduce((acc, photo)=>acc + ratio(photo), 0) / photos.length : 1;\n        for(let i = 0; i < columns; i += 1){\n            columnsGaps[i] = 2 * padding;\n            columnsRatios[i] = i < photos.length ? ratio(photos[i]) : averageRatio;\n        }\n        const columnsModel2 = buildColumnsModel({\n            path: Array.from({\n                length: columns + 1\n            }).map((_, index)=>Math.min(index, photos.length)),\n            photos,\n            columnsRatios,\n            columnsGaps,\n            containerWidth,\n            spacing,\n            padding\n        });\n        return {\n            columnsGaps,\n            columnsRatios,\n            columnsModel: columnsModel2\n        };\n    }\n    const targetColumnHeight = (photos.reduce((acc, photo)=>acc + targetColumnWidth / ratio(photo), 0) + spacing * (photos.length - columns) + 2 * padding * photos.length) / columns;\n    const getNeighbors = makeGetColumnNeighbors({\n        photos,\n        targetColumnWidth,\n        targetColumnHeight,\n        spacing,\n        padding\n    });\n    const path = findShortestPathLengthN(getNeighbors, columns, 0, photos.length);\n    for(let i = 0; i < path.length - 1; i += 1){\n        const column = photos.slice(path[i], path[i + 1]);\n        columnsGaps[i] = spacing * (column.length - 1) + 2 * padding * column.length;\n        columnsRatios[i] = 1 / column.reduce((acc, photo)=>acc + 1 / ratio(photo), 0);\n    }\n    const columnsModel = buildColumnsModel({\n        path,\n        photos,\n        columnsRatios,\n        columnsGaps,\n        containerWidth,\n        spacing,\n        padding\n    });\n    return {\n        columnsGaps,\n        columnsRatios,\n        columnsModel\n    };\n}\nfunction computeLayout(props) {\n    const { photos, layoutOptions } = props;\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const targetColumnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n    const { columnsGaps, columnsRatios, columnsModel } = computeColumnsModel({\n        photos,\n        layoutOptions,\n        targetColumnWidth\n    });\n    if (columnsModel.findIndex((columnModel)=>columnModel.findIndex((param)=>{\n            let { layout: { width, height } } = param;\n            return width < 0 || height < 0;\n        }) >= 0) >= 0) {\n        if (columns > 1) {\n            return computeLayout({\n                photos,\n                layoutOptions: {\n                    ...layoutOptions,\n                    columns: columns - 1\n                }\n            });\n        }\n        return void 0;\n    }\n    return {\n        columnsModel,\n        columnsGaps,\n        columnsRatios\n    };\n}\nfunction computeColumnsLayout(param) {\n    let { photos, layoutOptions } = param;\n    return computeLayout({\n        photos,\n        layoutOptions\n    });\n}\nfunction defaultRenderColumnContainer(param) {\n    let { columnContainerProps, children } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...columnContainerProps\n    }, children);\n}\nfunction cssColumnWidth(props) {\n    const { layoutOptions, columnIndex, columnsCount, columnsGaps, columnsRatios } = props;\n    const { layout, spacing, padding } = layoutOptions;\n    if (layout === \"masonry\" || !columnsGaps || !columnsRatios) {\n        return \"calc((100% - \".concat(spacing * (columnsCount - 1), \"px) / \").concat(columnsCount, \")\");\n    }\n    const totalRatio = columnsRatios.reduce((acc, ratio2)=>acc + ratio2, 0);\n    const totalAdjustedGaps = columnsRatios.reduce((acc, ratio2, index)=>acc + (columnsGaps[columnIndex] - columnsGaps[index]) * ratio2, 0);\n    return \"calc((100% - \".concat(round((columnsCount - 1) * spacing + 2 * columnsCount * padding + totalAdjustedGaps, 3), \"px) * \").concat(round(columnsRatios[columnIndex] / totalRatio, 5), \" + \").concat(2 * padding, \"px)\");\n}\nfunction ColumnContainerRenderer(props) {\n    const { layoutOptions, renderColumnContainer, children, columnContainerProps: { style, className, ...restColumnContainerProps } = {}, ...rest } = props;\n    const columnContainerProps = {\n        className: clsx(\"react-photo-album--column\", className),\n        style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            flexWrap: \"nowrap\",\n            alignItems: \"flex-start\",\n            width: cssColumnWidth(props),\n            justifyContent: layoutOptions.layout === \"columns\" ? \"space-between\" : \"flex-start\",\n            ...style\n        },\n        ...restColumnContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderColumnContainer != null ? renderColumnContainer : defaultRenderColumnContainer)({\n        layoutOptions,\n        columnContainerProps,\n        children,\n        ...rest\n    }));\n}\n_c3 = ColumnContainerRenderer;\nfunction ColumnsLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderColumnContainer, componentsProps: { imageProps, columnContainerProps } } = props;\n    const columnsLayout = computeColumnsLayout({\n        photos,\n        layoutOptions\n    });\n    if (!columnsLayout) return null;\n    const { columnsModel, columnsRatios, columnsGaps } = columnsLayout;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, columnsModel.map((column, columnIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnContainerRenderer, {\n            key: \"column-\".concat(columnIndex),\n            layoutOptions,\n            columnIndex,\n            columnsCount: columnsModel.length,\n            columnsGaps,\n            columnsRatios,\n            renderColumnContainer,\n            columnContainerProps\n        }, column.map((param)=>{\n            let { photo, layout } = param;\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            });\n        }))));\n}\n_c4 = ColumnsLayout;\nfunction computeMasonryLayout(props) {\n    const { photos, layoutOptions } = props;\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const columnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n    if (columnWidth <= 0) {\n        return columns > 1 ? computeMasonryLayout({\n            ...props,\n            layoutOptions: {\n                ...layoutOptions,\n                columns: columns - 1\n            }\n        }) : void 0;\n    }\n    const columnsCurrentTopPositions = [];\n    for(let i = 0; i < columns; i += 1){\n        columnsCurrentTopPositions[i] = 0;\n    }\n    const columnsModel = photos.reduce((model, photo, index)=>{\n        const shortestColumn = columnsCurrentTopPositions.reduce((currentShortestColumn, item, i)=>item < columnsCurrentTopPositions[currentShortestColumn] - 1 ? i : currentShortestColumn, 0);\n        columnsCurrentTopPositions[shortestColumn] = columnsCurrentTopPositions[shortestColumn] + columnWidth / ratio(photo) + spacing + 2 * padding;\n        model[shortestColumn].push({\n            photo,\n            index\n        });\n        return model;\n    }, Array.from({\n        length: columns\n    }).map(()=>[]));\n    return columnsModel.map((column)=>column.map((param, photoIndex)=>{\n            let { photo, index } = param;\n            return {\n                photo,\n                layout: {\n                    width: columnWidth,\n                    height: columnWidth / ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: column.length\n                }\n            };\n        }));\n}\nfunction MasonryLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderColumnContainer, componentsProps: { imageProps, columnContainerProps } } = props;\n    const masonryLayout = computeMasonryLayout({\n        photos,\n        layoutOptions\n    });\n    if (!masonryLayout) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, masonryLayout.map((column, columnIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnContainerRenderer, {\n            key: \"masonry-column-\".concat(columnIndex),\n            layoutOptions,\n            columnsCount: masonryLayout.length,\n            columnIndex,\n            renderColumnContainer,\n            columnContainerProps\n        }, column.map((param)=>{\n            let { photo, layout } = param;\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            });\n        }))));\n}\n_c5 = MasonryLayout;\nfunction defaultRenderContainer(param) {\n    let { containerProps, children, containerRef } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: containerRef,\n        ...containerProps\n    }, children);\n}\nfunction ContainerRenderer(props) {\n    const { layout, renderContainer, children, containerRef, containerProps: { style, className, ...restContainerProps } = {} } = props;\n    const containerProps = {\n        className: clsx(\"react-photo-album\", \"react-photo-album--\".concat(layout), className),\n        style: {\n            display: \"flex\",\n            flexWrap: \"nowrap\",\n            justifyContent: \"space-between\",\n            flexDirection: layout === \"rows\" ? \"column\" : \"row\",\n            ...style\n        },\n        ...restContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderContainer != null ? renderContainer : defaultRenderContainer)({\n        containerProps,\n        containerRef,\n        layout,\n        children\n    }));\n}\n_c6 = ContainerRenderer;\nfunction useArray(array) {\n    _s();\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(array);\n    if (!array || !ref.current || array.join() !== ref.current.join()) {\n        ref.current = array;\n    }\n    return ref.current;\n}\n_s(useArray, \"QMBuJFIdzLIeqBcFwhMf246mjOM=\");\nfunction containerWidthReducer(state, param) {\n    let { newContainerWidth, newScrollbarWidth } = param;\n    const { containerWidth, scrollbarWidth } = state;\n    if (containerWidth !== void 0 && scrollbarWidth !== void 0 && newContainerWidth !== void 0 && newScrollbarWidth !== void 0 && newContainerWidth > containerWidth && newContainerWidth - containerWidth <= 20 && newScrollbarWidth < scrollbarWidth) {\n        return {\n            containerWidth,\n            scrollbarWidth: newScrollbarWidth\n        };\n    }\n    return containerWidth !== newContainerWidth || scrollbarWidth !== newScrollbarWidth ? {\n        containerWidth: newContainerWidth,\n        scrollbarWidth: newScrollbarWidth\n    } : state;\n}\nfunction resolveContainerWidth(el, breakpoints2) {\n    let width = el == null ? void 0 : el.clientWidth;\n    if (width !== void 0 && breakpoints2 && breakpoints2.length > 0) {\n        const sorted = [\n            ...breakpoints2.filter((x)=>x > 0)\n        ].sort((a, b)=>b - a);\n        sorted.push(Math.floor(sorted[sorted.length - 1] / 2));\n        const threshold = width;\n        width = sorted.find((breakpoint, index)=>breakpoint <= threshold || index === sorted.length - 1);\n    }\n    return width;\n}\nfunction useContainerWidth(breakpoints2, defaultContainerWidth) {\n    _s1();\n    const [{ containerWidth }, dispatch] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(containerWidthReducer, {\n        containerWidth: defaultContainerWidth\n    });\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const observerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const containerRef = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        var _a;\n        (_a = observerRef.current) == null ? void 0 : _a.disconnect();\n        observerRef.current = void 0;\n        ref.current = node;\n        const updateWidth = ()=>dispatch({\n                newContainerWidth: resolveContainerWidth(ref.current, breakpoints2),\n                newScrollbarWidth: window.innerWidth - document.documentElement.clientWidth\n            });\n        updateWidth();\n        if (node && typeof ResizeObserver !== \"undefined\") {\n            observerRef.current = new ResizeObserver(updateWidth);\n            observerRef.current.observe(node);\n        }\n    }, [\n        breakpoints2\n    ]);\n    return {\n        containerRef,\n        containerWidth\n    };\n}\n_s1(useContainerWidth, \"QQb8shqBvt6r+XtIyI98MtfCIe8=\");\nconst breakpoints = Object.freeze([\n    1200,\n    600,\n    300,\n    0\n]);\nfunction unwrap(value, arg) {\n    return typeof value === \"function\" ? value(arg) : value;\n}\nfunction unwrapParameter(value, containerWidth) {\n    return typeof value !== \"undefined\" ? unwrap(value, containerWidth) : void 0;\n}\nfunction selectResponsiveValue(values, containerWidth) {\n    const index = breakpoints.findIndex((breakpoint)=>breakpoint <= containerWidth);\n    return unwrap(values[index >= 0 ? index : 0], containerWidth);\n}\nfunction resolveResponsiveParameter(parameter, containerWidth, values) {\n    let minValue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n    const value = unwrapParameter(parameter, containerWidth);\n    return Math.round(Math.max(value === void 0 ? selectResponsiveValue(values, containerWidth) : value, minValue));\n}\nfunction resolveLayoutOptions(param) {\n    let { layout, onClick, containerWidth, targetRowHeight, rowConstraints, columns, spacing, padding, sizes } = param;\n    return {\n        layout,\n        onClick,\n        containerWidth,\n        columns: resolveResponsiveParameter(columns, containerWidth, [\n            5,\n            4,\n            3,\n            2\n        ], 1),\n        spacing: resolveResponsiveParameter(spacing, containerWidth, [\n            20,\n            15,\n            10,\n            5\n        ]),\n        padding: resolveResponsiveParameter(padding, containerWidth, [\n            0,\n            0,\n            0,\n            0,\n            0\n        ]),\n        targetRowHeight: resolveResponsiveParameter(targetRowHeight, containerWidth, [\n            (w)=>w / 5,\n            (w)=>w / 4,\n            (w)=>w / 3,\n            (w)=>w / 2\n        ]),\n        rowConstraints: unwrapParameter(rowConstraints, containerWidth),\n        sizes\n    };\n}\nfunction resolveComponentsProps(props, containerWidth, layoutOptions) {\n    const { photos, componentsProps: componentsPropsProp } = props;\n    const componentsProps = unwrap(componentsPropsProp, containerWidth) || {};\n    if (layoutOptions) {\n        const { layout, spacing, padding, rowConstraints } = layoutOptions;\n        if (layout === \"rows\") {\n            const { singleRowMaxHeight } = rowConstraints || {};\n            if (singleRowMaxHeight) {\n                const maxWidth = Math.floor(photos.reduce((acc, param)=>{\n                    let { width, height } = param;\n                    return acc + width / height * singleRowMaxHeight - 2 * padding;\n                }, padding * photos.length * 2 + spacing * (photos.length - 1)));\n                if (maxWidth > 0) {\n                    componentsProps.containerProps = componentsProps.containerProps || {};\n                    componentsProps.containerProps.style = {\n                        maxWidth,\n                        ...componentsProps.containerProps.style\n                    };\n                }\n            }\n        }\n    }\n    return componentsProps;\n}\nfunction renderLayout(props, componentsProps, layoutOptions) {\n    const { photos, layout, renderPhoto, renderRowContainer, renderColumnContainer } = props;\n    const commonLayoutProps = {\n        photos,\n        renderPhoto,\n        componentsProps\n    };\n    if (layout === \"rows\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowsLayout, {\n            layoutOptions,\n            renderRowContainer,\n            ...commonLayoutProps\n        });\n    }\n    if (layout === \"columns\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnsLayout, {\n            layoutOptions,\n            renderColumnContainer,\n            ...commonLayoutProps\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MasonryLayout, {\n        layoutOptions,\n        renderColumnContainer,\n        ...commonLayoutProps\n    });\n}\nfunction PhotoAlbum(props) {\n    _s2();\n    const { photos, layout, renderContainer, defaultContainerWidth, breakpoints: breakpoints2 } = props;\n    const { containerRef, containerWidth } = useContainerWidth(useArray(breakpoints2), defaultContainerWidth);\n    if (!layout || ![\n        \"rows\",\n        \"columns\",\n        \"masonry\"\n    ].includes(layout) || !Array.isArray(photos)) return null;\n    const layoutOptions = containerWidth ? resolveLayoutOptions({\n        containerWidth,\n        ...props\n    }) : void 0;\n    const componentsProps = resolveComponentsProps(props, containerWidth, layoutOptions);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContainerRenderer, {\n        layout,\n        containerRef,\n        renderContainer,\n        containerProps: componentsProps.containerProps\n    }, layoutOptions && renderLayout(props, componentsProps, layoutOptions));\n}\n_s2(PhotoAlbum, \"C6RGXm7DIJTv7bGrYxU5skohLUY=\", false, function() {\n    return [\n        useContainerWidth\n    ];\n});\n_c7 = PhotoAlbum;\n\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7;\n$RefreshReg$(_c, \"PhotoRenderer\");\n$RefreshReg$(_c1, \"RowContainerRenderer\");\n$RefreshReg$(_c2, \"RowsLayout\");\n$RefreshReg$(_c3, \"ColumnContainerRenderer\");\n$RefreshReg$(_c4, \"ColumnsLayout\");\n$RefreshReg$(_c5, \"MasonryLayout\");\n$RefreshReg$(_c6, \"ContainerRenderer\");\n$RefreshReg$(_c7, \"PhotoAlbum\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1waG90by1hbGJ1bS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQytCO0FBQy9CLFNBQVNDLE1BQU0sS0FBaUI7UUFBakIsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBakI7SUFDYixPQUFPRCxRQUFRQztBQUNqQjtBQUNBLFNBQVNDLE1BQU1DLEtBQUs7UUFBRUMsV0FBQUEsaUVBQVc7SUFDL0IsTUFBTUMsU0FBUyxNQUFNRDtJQUNyQixPQUFPRSxLQUFLSixLQUFLLENBQUMsQ0FBQ0MsUUFBUUksT0FBT0MsT0FBTyxJQUFJSCxVQUFVQTtBQUN6RDtBQUNBLFNBQVNJLDBCQUEwQkMsSUFBSTtJQUNyQyxPQUFPLENBQUNDLEdBQUdDLElBQU1GLEtBQUtFLEtBQUtGLEtBQUtDO0FBQ2xDO0FBQ0EsTUFBTUU7SUFNSkMsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQ0MsVUFBVSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxDQUFDSCxFQUFFLEVBQUUsSUFBSSxDQUFDRyxJQUFJLENBQUNGLEVBQUUsSUFBSTtJQUN2RDtJQUNBRyxLQUFLSixDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNULE1BQU1JLE9BQU8sSUFBSSxDQUFDRixJQUFJLENBQUNILEVBQUU7UUFDekIsSUFBSSxDQUFDRyxJQUFJLENBQUNILEVBQUUsR0FBRyxJQUFJLENBQUNHLElBQUksQ0FBQ0YsRUFBRTtRQUMzQixJQUFJLENBQUNFLElBQUksQ0FBQ0YsRUFBRSxHQUFHSTtJQUNqQjtJQUNBQyxLQUFLTixDQUFDLEVBQUU7UUFDTixJQUFJTyxJQUFJUDtRQUNSLElBQUlRLEtBQUtqQixLQUFLa0IsS0FBSyxDQUFDRixJQUFJO1FBQ3hCLE1BQU9BLElBQUksS0FBSyxJQUFJLENBQUNSLE9BQU8sQ0FBQ1MsSUFBSUQsR0FBSTtZQUNuQyxJQUFJLENBQUNILElBQUks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Oi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1waG90by1hbGJ1bS9kaXN0L2luZGV4Lm1qcz9iNDY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiByYXRpbyh7IHdpZHRoLCBoZWlnaHQgfSkge1xuICByZXR1cm4gd2lkdGggLyBoZWlnaHQ7XG59XG5mdW5jdGlvbiByb3VuZCh2YWx1ZSwgZGVjaW1hbHMgPSAwKSB7XG4gIGNvbnN0IGZhY3RvciA9IDEwICoqIGRlY2ltYWxzO1xuICByZXR1cm4gTWF0aC5yb3VuZCgodmFsdWUgKyBOdW1iZXIuRVBTSUxPTikgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuZnVuY3Rpb24gcmFua2luZ0Z1bmN0aW9uQ29tcGFyYXRvcihyYW5rKSB7XG4gIHJldHVybiAoYSwgYikgPT4gcmFuayhiKSAtIHJhbmsoYSk7XG59XG5jbGFzcyBNaW5IZWFwIHtcbiAgY29uc3RydWN0b3IoY29tcGFyYXRvcikge1xuICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgdGhpcy5oZWFwID0gW107XG4gICAgdGhpcy5uID0gMDtcbiAgfVxuICBncmVhdGVyKGksIGopIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJhdG9yKHRoaXMuaGVhcFtpXSwgdGhpcy5oZWFwW2pdKSA8IDA7XG4gIH1cbiAgc3dhcChpLCBqKSB7XG4gICAgY29uc3QgdGVtcCA9IHRoaXMuaGVhcFtpXTtcbiAgICB0aGlzLmhlYXBbaV0gPSB0aGlzLmhlYXBbal07XG4gICAgdGhpcy5oZWFwW2pdID0gdGVtcDtcbiAgfVxuICBzd2ltKGkpIHtcbiAgICBsZXQgayA9IGk7XG4gICAgbGV0IGsyID0gTWF0aC5mbG9vcihrIC8gMik7XG4gICAgd2hpbGUgKGsgPiAxICYmIHRoaXMuZ3JlYXRlcihrMiwgaykpIHtcbiAgICAgIHRoaXMuc3dhcChrMiwgayk7XG4gICAgICBrID0gazI7XG4gICAgICBrMiA9IE1hdGguZmxvb3IoayAvIDIpO1xuICAgIH1cbiAgfVxuICBzaW5rKGkpIHtcbiAgICBsZXQgayA9IGk7XG4gICAgbGV0IGsyID0gayAqIDI7XG4gICAgd2hpbGUgKGsyIDw9IHRoaXMubikge1xuICAgICAgaWYgKGsyIDwgdGhpcy5uICYmIHRoaXMuZ3JlYXRlcihrMiwgazIgKyAxKSlcbiAgICAgICAgazIgKz0gMTtcbiAgICAgIGlmICghdGhpcy5ncmVhdGVyKGssIGsyKSlcbiAgICAgICAgYnJlYWs7XG4gICAgICB0aGlzLnN3YXAoaywgazIpO1xuICAgICAgayA9IGsyO1xuICAgICAgazIgPSBrICogMjtcbiAgICB9XG4gIH1cbiAgcHVzaChlbGVtZW50KSB7XG4gICAgdGhpcy5uICs9IDE7XG4gICAgdGhpcy5oZWFwW3RoaXMubl0gPSBlbGVtZW50O1xuICAgIHRoaXMuc3dpbSh0aGlzLm4pO1xuICB9XG4gIHBvcCgpIHtcbiAgICBpZiAodGhpcy5uID09PSAwKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB0aGlzLnN3YXAoMSwgdGhpcy5uKTtcbiAgICB0aGlzLm4gLT0gMTtcbiAgICBjb25zdCBtYXggPSB0aGlzLmhlYXAucG9wKCk7XG4gICAgdGhpcy5zaW5rKDEpO1xuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZFByZWNlZGVudHNNYXAoZ3JhcGgsIHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xuICBjb25zdCBwcmVjZWRlbnRzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdmlzaXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHN0b3JlZFNob3J0ZXN0UGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdG9yZWRTaG9ydGVzdFBhdGhzLnNldChzdGFydE5vZGUsIDApO1xuICBjb25zdCBxdWV1ZSA9IG5ldyBNaW5IZWFwKHJhbmtpbmdGdW5jdGlvbkNvbXBhcmF0b3IoKGVsKSA9PiBlbC53ZWlnaHQpKTtcbiAgcXVldWUucHVzaCh7IGlkOiBzdGFydE5vZGUsIHdlaWdodDogMCB9KTtcbiAgd2hpbGUgKHF1ZXVlLnNpemUoKSA+IDApIHtcbiAgICBjb25zdCB7IGlkLCB3ZWlnaHQgfSA9IHF1ZXVlLnBvcCgpO1xuICAgIGlmICghdmlzaXRlZC5oYXMoaWQpKSB7XG4gICAgICBjb25zdCBuZWlnaGJvcmluZ05vZGVzID0gZ3JhcGgoaWQpO1xuICAgICAgdmlzaXRlZC5hZGQoaWQpO1xuICAgICAgbmVpZ2hib3JpbmdOb2Rlcy5mb3JFYWNoKChuZWlnaGJvcldlaWdodCwgbmVpZ2hib3IpID0+IHtcbiAgICAgICAgY29uc3QgbmV3V2VpZ2h0ID0gd2VpZ2h0ICsgbmVpZ2hib3JXZWlnaHQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJZCA9IHByZWNlZGVudHNNYXAuZ2V0KG5laWdoYm9yKTtcbiAgICAgICAgY29uc3QgY3VycmVudFdlaWdodCA9IHN0b3JlZFNob3J0ZXN0UGF0aHMuZ2V0KG5laWdoYm9yKTtcbiAgICAgICAgaWYgKGN1cnJlbnRXZWlnaHQgPT09IHZvaWQgMCB8fCBjdXJyZW50V2VpZ2h0ID4gbmV3V2VpZ2h0ICYmIChjdXJyZW50V2VpZ2h0IC8gbmV3V2VpZ2h0ID4gMS4wMDUgfHwgY3VycmVudElkICE9PSB2b2lkIDAgJiYgY3VycmVudElkIDwgaWQpKSB7XG4gICAgICAgICAgc3RvcmVkU2hvcnRlc3RQYXRocy5zZXQobmVpZ2hib3IsIG5ld1dlaWdodCk7XG4gICAgICAgICAgcXVldWUucHVzaCh7IGlkOiBuZWlnaGJvciwgd2VpZ2h0OiBuZXdXZWlnaHQgfSk7XG4gICAgICAgICAgcHJlY2VkZW50c01hcC5zZXQobmVpZ2hib3IsIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdG9yZWRTaG9ydGVzdFBhdGhzLmhhcyhlbmROb2RlKSA/IHByZWNlZGVudHNNYXAgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRQYXRoRnJvbVByZWNlZGVudHNNYXAocHJlY2VkZW50c01hcCwgZW5kTm9kZSkge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBmb3IgKGxldCBub2RlID0gZW5kTm9kZTsgbm9kZSAhPT0gdm9pZCAwOyBub2RlID0gcHJlY2VkZW50c01hcC5nZXQobm9kZSkpIHtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBub2Rlcy5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBmaW5kU2hvcnRlc3RQYXRoKGdyYXBoLCBzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgY29uc3QgcHJlY2VkZW50c01hcCA9IGJ1aWxkUHJlY2VkZW50c01hcChncmFwaCwgc3RhcnROb2RlLCBlbmROb2RlKTtcbiAgcmV0dXJuIHByZWNlZGVudHNNYXAgPyBnZXRQYXRoRnJvbVByZWNlZGVudHNNYXAocHJlY2VkZW50c01hcCwgZW5kTm9kZSkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBmaW5kSWRlYWxOb2RlU2VhcmNoKHtcbiAgcGhvdG9zLFxuICB0YXJnZXRSb3dIZWlnaHQsXG4gIGNvbnRhaW5lcldpZHRoXG59KSB7XG4gIGNvbnN0IG1pblJhdGlvID0gcGhvdG9zLnJlZHVjZSgoYWNjLCBwaG90bykgPT4gTWF0aC5taW4ocmF0aW8ocGhvdG8pLCBhY2MpLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgcmV0dXJuIHJvdW5kKGNvbnRhaW5lcldpZHRoIC8gdGFyZ2V0Um93SGVpZ2h0IC8gbWluUmF0aW8pICsgMjtcbn1cbmZ1bmN0aW9uIGdldENvbW1vbkhlaWdodChyb3csIGNvbnRhaW5lcldpZHRoLCBzcGFjaW5nLCBwYWRkaW5nKSB7XG4gIGNvbnN0IHJvd1dpZHRoID0gY29udGFpbmVyV2lkdGggLSAocm93Lmxlbmd0aCAtIDEpICogc3BhY2luZyAtIDIgKiBwYWRkaW5nICogcm93Lmxlbmd0aDtcbiAgY29uc3QgdG90YWxBc3BlY3RSYXRpbyA9IHJvdy5yZWR1Y2UoKGFjYywgcGhvdG8pID0+IGFjYyArIHJhdGlvKHBob3RvKSwgMCk7XG4gIHJldHVybiByb3dXaWR0aCAvIHRvdGFsQXNwZWN0UmF0aW87XG59XG5mdW5jdGlvbiBjb3N0KHBob3RvcywgaSwgaiwgd2lkdGgsIHRhcmdldFJvd0hlaWdodCwgc3BhY2luZywgcGFkZGluZykge1xuICBjb25zdCByb3cgPSBwaG90b3Muc2xpY2UoaSwgaik7XG4gIGNvbnN0IGNvbW1vbkhlaWdodCA9IGdldENvbW1vbkhlaWdodChyb3csIHdpZHRoLCBzcGFjaW5nLCBwYWRkaW5nKTtcbiAgcmV0dXJuIGNvbW1vbkhlaWdodCA+IDAgPyAoY29tbW9uSGVpZ2h0IC0gdGFyZ2V0Um93SGVpZ2h0KSAqKiAyICogcm93Lmxlbmd0aCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIG1ha2VHZXRSb3dOZWlnaGJvcnMoe1xuICBwaG90b3MsXG4gIGxheW91dE9wdGlvbnMsXG4gIHRhcmdldFJvd0hlaWdodCxcbiAgbGltaXROb2RlU2VhcmNoLFxuICByb3dDb25zdHJhaW50c1xufSkge1xuICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgY29udGFpbmVyV2lkdGgsIHNwYWNpbmcsIHBhZGRpbmcgfSA9IGxheW91dE9wdGlvbnM7XG4gICAgY29uc3QgcmVzdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgcmVzdWx0cy5zZXQobm9kZSwgMCk7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSAoX2EgPSByb3dDb25zdHJhaW50cyA9PSBudWxsID8gdm9pZCAwIDogcm93Q29uc3RyYWludHMubWluUGhvdG9zKSAhPSBudWxsID8gX2EgOiAxO1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IE1hdGgubWluKGxpbWl0Tm9kZVNlYXJjaCwgKF9iID0gcm93Q29uc3RyYWludHMgPT0gbnVsbCA/IHZvaWQgMCA6IHJvd0NvbnN0cmFpbnRzLm1heFBob3RvcykgIT0gbnVsbCA/IF9iIDogSW5maW5pdHkpO1xuICAgIGZvciAobGV0IGkgPSBub2RlICsgc3RhcnRPZmZzZXQ7IGkgPCBwaG90b3MubGVuZ3RoICsgMTsgaSArPSAxKSB7XG4gICAgICBpZiAoaSAtIG5vZGUgPiBlbmRPZmZzZXQpXG4gICAgICAgIGJyZWFrO1xuICAgICAgY29uc3QgY3VycmVudENvc3QgPSBjb3N0KHBob3Rvcywgbm9kZSwgaSwgY29udGFpbmVyV2lkdGgsIHRhcmdldFJvd0hlaWdodCwgc3BhY2luZywgcGFkZGluZyk7XG4gICAgICBpZiAoY3VycmVudENvc3QgPT09IHZvaWQgMClcbiAgICAgICAgYnJlYWs7XG4gICAgICByZXN1bHRzLnNldChpLCBjdXJyZW50Q29zdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZVJvd3NMYXlvdXQoe1xuICBwaG90b3MsXG4gIGxheW91dE9wdGlvbnNcbn0pIHtcbiAgY29uc3QgeyBzcGFjaW5nLCBwYWRkaW5nLCBjb250YWluZXJXaWR0aCwgdGFyZ2V0Um93SGVpZ2h0LCByb3dDb25zdHJhaW50cyB9ID0gbGF5b3V0T3B0aW9ucztcbiAgY29uc3QgbGltaXROb2RlU2VhcmNoID0gZmluZElkZWFsTm9kZVNlYXJjaCh7IHBob3RvcywgY29udGFpbmVyV2lkdGgsIHRhcmdldFJvd0hlaWdodCB9KTtcbiAgY29uc3QgZ2V0TmVpZ2hib3JzID0gbWFrZUdldFJvd05laWdoYm9ycyh7XG4gICAgcGhvdG9zLFxuICAgIGxheW91dE9wdGlvbnMsXG4gICAgdGFyZ2V0Um93SGVpZ2h0LFxuICAgIGxpbWl0Tm9kZVNlYXJjaCxcbiAgICByb3dDb25zdHJhaW50c1xuICB9KTtcbiAgY29uc3QgcGF0aCA9IGZpbmRTaG9ydGVzdFBhdGgoZ2V0TmVpZ2hib3JzLCAwLCBwaG90b3MubGVuZ3RoKTtcbiAgaWYgKHBhdGggPT09IHZvaWQgMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBsYXlvdXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXRoLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qgcm93ID0gcGhvdG9zLm1hcCgocGhvdG8sIGluZGV4KSA9PiAoeyBwaG90bywgaW5kZXggfSkpLnNsaWNlKHBhdGhbaSAtIDFdLCBwYXRoW2ldKTtcbiAgICBjb25zdCBoZWlnaHQgPSBnZXRDb21tb25IZWlnaHQoXG4gICAgICByb3cubWFwKCh7IHBob3RvIH0pID0+IHBob3RvKSxcbiAgICAgIGNvbnRhaW5lcldpZHRoLFxuICAgICAgc3BhY2luZyxcbiAgICAgIHBhZGRpbmdcbiAgICApO1xuICAgIGxheW91dC5wdXNoKFxuICAgICAgcm93Lm1hcCgoeyBwaG90bywgaW5kZXggfSwgcGhvdG9JbmRleCkgPT4gKHtcbiAgICAgICAgcGhvdG8sXG4gICAgICAgIGxheW91dDoge1xuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICB3aWR0aDogaGVpZ2h0ICogcmF0aW8ocGhvdG8pLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHBob3RvSW5kZXgsXG4gICAgICAgICAgcGhvdG9zQ291bnQ6IHJvdy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbGF5b3V0O1xufVxuZnVuY3Rpb24gY2xzeCguLi5jbGFzc2VzKSB7XG4gIHJldHVybiBbLi4uY2xhc3Nlc10uZmlsdGVyKChjbHMpID0+IEJvb2xlYW4oY2xzKSkuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBjYWxjV2lkdGgoYmFzZSwgeyB3aWR0aCwgcGhvdG9zQ291bnQgfSwgeyBzcGFjaW5nLCBwYWRkaW5nLCBjb250YWluZXJXaWR0aCB9KSB7XG4gIGNvbnN0IGdhcHMgPSBzcGFjaW5nICogKHBob3Rvc0NvdW50IC0gMSkgKyAyICogcGFkZGluZyAqIHBob3Rvc0NvdW50O1xuICByZXR1cm4gYGNhbGMoKCR7YmFzZX0gLSAke2dhcHN9cHgpIC8gJHtyb3VuZCgoY29udGFpbmVyV2lkdGggLSBnYXBzKSAvIHdpZHRoLCA1KX0pYDtcbn1cbmZ1bmN0aW9uIGNzc1Bob3RvV2lkdGgobGF5b3V0LCBsYXlvdXRPcHRpb25zKSB7XG4gIHJldHVybiBsYXlvdXRPcHRpb25zLmxheW91dCAhPT0gXCJyb3dzXCIgPyBgY2FsYygxMDAlIC0gJHsyICogbGF5b3V0T3B0aW9ucy5wYWRkaW5nfXB4KWAgOiBjYWxjV2lkdGgoXCIxMDAlXCIsIGxheW91dCwgbGF5b3V0T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTaXplc1ZhbHVlKHNpemUsIGxheW91dCwgbGF5b3V0T3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICByZXR1cm4gY2FsY1dpZHRoKChfYiA9IChfYSA9IHNpemUubWF0Y2goL15cXHMqY2FsY1xcKCguKilcXClcXHMqJC8pKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMV0pICE9IG51bGwgPyBfYiA6IHNpemUsIGxheW91dCwgbGF5b3V0T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcmNTZXRBbmRTaXplcyhwaG90bywgbGF5b3V0LCBsYXlvdXRPcHRpb25zKSB7XG4gIGxldCBzcmNTZXQ7XG4gIGxldCBzaXplcztcbiAgY29uc3QgaW1hZ2VzID0gcGhvdG8uc3JjU2V0IHx8IHBob3RvLmltYWdlcztcbiAgaWYgKGltYWdlcyAmJiBpbWFnZXMubGVuZ3RoID4gMCkge1xuICAgIHNyY1NldCA9IGltYWdlcy5jb25jYXQoXG4gICAgICAhaW1hZ2VzLmZpbmQoKHsgd2lkdGggfSkgPT4gd2lkdGggPT09IHBob3RvLndpZHRoKSA/IFt7IHNyYzogcGhvdG8uc3JjLCB3aWR0aDogcGhvdG8ud2lkdGgsIGhlaWdodDogcGhvdG8uaGVpZ2h0IH1dIDogW11cbiAgICApLnNvcnQoKGZpcnN0LCBzZWNvbmQpID0+IGZpcnN0LndpZHRoIC0gc2Vjb25kLndpZHRoKS5tYXAoKGltYWdlKSA9PiBgJHtpbWFnZS5zcmN9ICR7aW1hZ2Uud2lkdGh9d2ApLmpvaW4oXCIsIFwiKTtcbiAgfVxuICBpZiAobGF5b3V0T3B0aW9ucy5zaXplcykge1xuICAgIHNpemVzID0gKGxheW91dE9wdGlvbnMuc2l6ZXMuc2l6ZXMgfHwgW10pLm1hcCgoeyB2aWV3cG9ydCwgc2l6ZSB9KSA9PiBgJHt2aWV3cG9ydH0gJHtjYWxjdWxhdGVTaXplc1ZhbHVlKHNpemUsIGxheW91dCwgbGF5b3V0T3B0aW9ucyl9YCkuY29uY2F0KGNhbGN1bGF0ZVNpemVzVmFsdWUobGF5b3V0T3B0aW9ucy5zaXplcy5zaXplLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpKS5qb2luKFwiLCBcIik7XG4gIH0gZWxzZSBpZiAoc3JjU2V0KSB7XG4gICAgc2l6ZXMgPSBgJHtNYXRoLmNlaWwobGF5b3V0LndpZHRoIC8gbGF5b3V0T3B0aW9ucy5jb250YWluZXJXaWR0aCAqIDEwMCl9dndgO1xuICB9XG4gIHJldHVybiB7IHNyY1NldCwgc2l6ZXMgfTtcbn1cbmZ1bmN0aW9uIFBob3RvUmVuZGVyZXIocHJvcHMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgeyBwaG90bywgbGF5b3V0LCBsYXlvdXRPcHRpb25zLCBpbWFnZVByb3BzOiB7IHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3RJbWFnZVByb3BzIH0gPSB7fSwgcmVuZGVyUGhvdG8gfSA9IHByb3BzO1xuICBjb25zdCB7IG9uQ2xpY2sgfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGltYWdlU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgIGJveFNpemluZzogXCJjb250ZW50LWJveFwiLFxuICAgIHdpZHRoOiBjc3NQaG90b1dpZHRoKGxheW91dCwgbGF5b3V0T3B0aW9ucyksXG4gICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICBhc3BlY3RSYXRpbzogYCR7cGhvdG8ud2lkdGh9IC8gJHtwaG90by5oZWlnaHR9YCxcbiAgICAuLi5sYXlvdXRPcHRpb25zLnBhZGRpbmcgPyB7IHBhZGRpbmc6IGAke2xheW91dE9wdGlvbnMucGFkZGluZ31weGAgfSA6IG51bGwsXG4gICAgLi4uKGxheW91dE9wdGlvbnMubGF5b3V0ID09PSBcImNvbHVtbnNcIiB8fCBsYXlvdXRPcHRpb25zLmxheW91dCA9PT0gXCJtYXNvbnJ5XCIpICYmIGxheW91dC5waG90b0luZGV4IDwgbGF5b3V0LnBob3Rvc0NvdW50IC0gMSA/IHsgbWFyZ2luQm90dG9tOiBgJHtsYXlvdXRPcHRpb25zLnNwYWNpbmd9cHhgIH0gOiBudWxsLFxuICAgIC4uLm9uQ2xpY2sgPyB7IGN1cnNvcjogXCJwb2ludGVyXCIgfSA6IG51bGwsXG4gICAgLi4uc3R5bGVcbiAgfTtcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSBvbkNsaWNrID8gKGV2ZW50KSA9PiB7XG4gICAgb25DbGljayh7IGV2ZW50LCBwaG90bywgaW5kZXg6IGxheW91dC5pbmRleCB9KTtcbiAgfSA6IHZvaWQgMDtcbiAgY29uc3QgaW1hZ2VQcm9wcyA9IHtcbiAgICBzcmM6IHBob3RvLnNyYyxcbiAgICBhbHQ6IChfYSA9IHBob3RvLmFsdCkgIT0gbnVsbCA/IF9hIDogXCJcIixcbiAgICB0aXRsZTogcGhvdG8udGl0bGUsXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgc3R5bGU6IGltYWdlU3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbHN4KFwicmVhY3QtcGhvdG8tYWxidW0tLXBob3RvXCIsIGNsYXNzTmFtZSksXG4gICAgbG9hZGluZzogXCJsYXp5XCIsXG4gICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAuLi5zcmNTZXRBbmRTaXplcyhwaG90bywgbGF5b3V0LCBsYXlvdXRPcHRpb25zKSxcbiAgICAuLi5yZXN0SW1hZ2VQcm9wc1xuICB9O1xuICBjb25zdCByZW5kZXJEZWZhdWx0UGhvdG8gPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgc3JjLCBhbHQsIHNyY1NldCwgc2l6ZXMsIHN0eWxlOiB1bndyYXBwZWRTdHlsZSwgLi4ucmVzdCB9ID0gaW1hZ2VQcm9wcztcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiaW1nXCIsXG4gICAgICB7XG4gICAgICAgIGFsdCxcbiAgICAgICAgLi4uc3JjU2V0ID8geyBzcmNTZXQsIHNpemVzIH0gOiBudWxsLFxuICAgICAgICBzcmMsXG4gICAgICAgIHN0eWxlOiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy53cmFwcGVkKSA/IHsgZGlzcGxheTogXCJibG9ja1wiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfSA6IHVud3JhcHBlZFN0eWxlLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9XG4gICAgKTtcbiAgfTtcbiAgY29uc3Qgd3JhcHBlclN0eWxlID0gKCh7IGRpc3BsYXksIGJveFNpemluZywgd2lkdGgsIGFzcGVjdFJhdGlvLCBwYWRkaW5nLCBtYXJnaW5Cb3R0b20sIGN1cnNvciB9KSA9PiAoe1xuICAgIGRpc3BsYXksXG4gICAgYm94U2l6aW5nLFxuICAgIHdpZHRoLFxuICAgIGFzcGVjdFJhdGlvLFxuICAgIHBhZGRpbmcsXG4gICAgbWFyZ2luQm90dG9tLFxuICAgIGN1cnNvclxuICB9KSkoaW1hZ2VTdHlsZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAoX2IgPSByZW5kZXJQaG90byA9PSBudWxsID8gdm9pZCAwIDogcmVuZGVyUGhvdG8oe1xuICAgIHBob3RvLFxuICAgIGxheW91dCxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIGltYWdlUHJvcHMsXG4gICAgcmVuZGVyRGVmYXVsdFBob3RvLFxuICAgIHdyYXBwZXJTdHlsZVxuICB9KSkgIT0gbnVsbCA/IF9iIDogcmVuZGVyRGVmYXVsdFBob3RvKCkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclJvd0NvbnRhaW5lcih7XG4gIHJvd0NvbnRhaW5lclByb3BzLFxuICBjaGlsZHJlblxufSkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLnJvd0NvbnRhaW5lclByb3BzIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIFJvd0NvbnRhaW5lclJlbmRlcmVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJvd0luZGV4LFxuICAgIHJvd3NDb3VudCxcbiAgICByZW5kZXJSb3dDb250YWluZXIsXG4gICAgcm93Q29udGFpbmVyUHJvcHM6IHsgc3R5bGUsIGNsYXNzTmFtZSwgLi4ucmVzdFJvd0NvbnRhaW5lclByb3BzIH0gPSB7fSxcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJvd0NvbnRhaW5lclByb3BzID0ge1xuICAgIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LXBob3RvLWFsYnVtLS1yb3dcIiwgY2xhc3NOYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBcInJvd1wiLFxuICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIixcbiAgICAgIGp1c3RpZnlDb250ZW50OiBcInNwYWNlLWJldHdlZW5cIixcbiAgICAgIC4uLnJvd0luZGV4IDwgcm93c0NvdW50IC0gMSA/IHsgbWFyZ2luQm90dG9tOiBgJHtsYXlvdXRPcHRpb25zLnNwYWNpbmd9cHhgIH0gOiBudWxsLFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIC4uLnJlc3RSb3dDb250YWluZXJQcm9wc1xuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgKHJlbmRlclJvd0NvbnRhaW5lciAhPSBudWxsID8gcmVuZGVyUm93Q29udGFpbmVyIDogZGVmYXVsdFJlbmRlclJvd0NvbnRhaW5lcikoe1xuICAgIGxheW91dE9wdGlvbnMsXG4gICAgcm93SW5kZXgsXG4gICAgcm93c0NvdW50LFxuICAgIHJvd0NvbnRhaW5lclByb3BzLFxuICAgIGNoaWxkcmVuXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIFJvd3NMYXlvdXQocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJlbmRlclBob3RvLFxuICAgIHJlbmRlclJvd0NvbnRhaW5lcixcbiAgICBjb21wb25lbnRzUHJvcHM6IHsgaW1hZ2VQcm9wcywgcm93Q29udGFpbmVyUHJvcHMgfVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJvd3NMYXlvdXQgPSBjb21wdXRlUm93c0xheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9KTtcbiAgaWYgKCFyb3dzTGF5b3V0KVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcm93c0xheW91dC5tYXAoKHJvdywgcm93SW5kZXgpID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgUm93Q29udGFpbmVyUmVuZGVyZXIsXG4gICAge1xuICAgICAga2V5OiBgcm93LSR7cm93SW5kZXh9YCxcbiAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICByb3dJbmRleCxcbiAgICAgIHJvd3NDb3VudDogcm93c0xheW91dC5sZW5ndGgsXG4gICAgICByZW5kZXJSb3dDb250YWluZXIsXG4gICAgICByb3dDb250YWluZXJQcm9wc1xuICAgIH0sXG4gICAgcm93Lm1hcCgoeyBwaG90bywgbGF5b3V0IH0pID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBQaG90b1JlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBrZXk6IHBob3RvLmtleSB8fCBwaG90by5zcmMsXG4gICAgICAgIHBob3RvLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIHJlbmRlclBob3RvLFxuICAgICAgICBpbWFnZVByb3BzXG4gICAgICB9XG4gICAgKSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNob3J0ZXN0UGF0aChncmFwaCwgcGF0aExlbmd0aCwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IG1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHF1ZXVlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcXVldWUuYWRkKHN0YXJ0Tm9kZSk7XG4gIGZvciAobGV0IGxlbmd0aCA9IDA7IGxlbmd0aCA8IHBhdGhMZW5ndGg7IGxlbmd0aCArPSAxKSB7XG4gICAgY29uc3QgY3VycmVudFF1ZXVlID0gWy4uLnF1ZXVlLmtleXMoKV07XG4gICAgcXVldWUuY2xlYXIoKTtcbiAgICBjdXJyZW50UXVldWUuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgY29uc3QgYWNjdW11bGF0ZWRXZWlnaHQgPSBsZW5ndGggPiAwID8gbWF0cml4LmdldChub2RlKVtsZW5ndGhdLndlaWdodCA6IDA7XG4gICAgICBncmFwaChub2RlKS5mb3JFYWNoKCh7IG5laWdoYm9yLCB3ZWlnaHQgfSkgPT4ge1xuICAgICAgICBsZXQgcGF0aHMgPSBtYXRyaXguZ2V0KG5laWdoYm9yKTtcbiAgICAgICAgaWYgKCFwYXRocykge1xuICAgICAgICAgIHBhdGhzID0gW107XG4gICAgICAgICAgbWF0cml4LnNldChuZWlnaGJvciwgcGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1dlaWdodCA9IGFjY3VtdWxhdGVkV2VpZ2h0ICsgd2VpZ2h0O1xuICAgICAgICBjb25zdCBuZXh0UGF0aCA9IHBhdGhzW2xlbmd0aCArIDFdO1xuICAgICAgICBpZiAoIW5leHRQYXRoIHx8IG5leHRQYXRoLndlaWdodCA+IG5ld1dlaWdodCAmJiAobmV4dFBhdGgud2VpZ2h0IC8gbmV3V2VpZ2h0ID4gMS4wMDAxIHx8IG5vZGUgPCBuZXh0UGF0aC5ub2RlKSkge1xuICAgICAgICAgIHBhdGhzW2xlbmd0aCArIDFdID0geyBub2RlLCB3ZWlnaHQ6IG5ld1dlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPCBwYXRoTGVuZ3RoIC0gMSAmJiBuZWlnaGJvciAhPT0gZW5kTm9kZSkge1xuICAgICAgICAgIHF1ZXVlLmFkZChuZWlnaGJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5mdW5jdGlvbiByZWNvbnN0cnVjdFNob3J0ZXN0UGF0aChtYXRyaXgsIHBhdGhMZW5ndGgsIGVuZE5vZGUpIHtcbiAgY29uc3QgcGF0aCA9IFtlbmROb2RlXTtcbiAgZm9yIChsZXQgbm9kZSA9IGVuZE5vZGUsIGxlbmd0aCA9IHBhdGhMZW5ndGg7IGxlbmd0aCA+IDA7IGxlbmd0aCAtPSAxKSB7XG4gICAgbm9kZSA9IG1hdHJpeC5nZXQobm9kZSlbbGVuZ3RoXS5ub2RlO1xuICAgIHBhdGgucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBmaW5kU2hvcnRlc3RQYXRoTGVuZ3RoTihncmFwaCwgcGF0aExlbmd0aCwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIHJldHVybiByZWNvbnN0cnVjdFNob3J0ZXN0UGF0aChjb21wdXRlU2hvcnRlc3RQYXRoKGdyYXBoLCBwYXRoTGVuZ3RoLCBzdGFydE5vZGUsIGVuZE5vZGUpLCBwYXRoTGVuZ3RoLCBlbmROb2RlKTtcbn1cbmZ1bmN0aW9uIG1ha2VHZXRDb2x1bW5OZWlnaGJvcnMoe1xuICBwaG90b3MsXG4gIHNwYWNpbmcsXG4gIHBhZGRpbmcsXG4gIHRhcmdldENvbHVtbldpZHRoLFxuICB0YXJnZXRDb2x1bW5IZWlnaHRcbn0pIHtcbiAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IGN1dE9mZkhlaWdodCA9IHRhcmdldENvbHVtbkhlaWdodCAqIDEuNTtcbiAgICBsZXQgaGVpZ2h0ID0gdGFyZ2V0Q29sdW1uV2lkdGggLyByYXRpbyhwaG90b3Nbbm9kZV0pICsgMiAqIHBhZGRpbmc7XG4gICAgZm9yIChsZXQgaSA9IG5vZGUgKyAxOyBpIDwgcGhvdG9zLmxlbmd0aCArIDE7IGkgKz0gMSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHsgbmVpZ2hib3I6IGksIHdlaWdodDogKHRhcmdldENvbHVtbkhlaWdodCAtIGhlaWdodCkgKiogMiB9KTtcbiAgICAgIGlmIChoZWlnaHQgPiBjdXRPZmZIZWlnaHQgfHwgaSA9PT0gcGhvdG9zLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGhlaWdodCArPSB0YXJnZXRDb2x1bW5XaWR0aCAvIHJhdGlvKHBob3Rvc1tpXSkgKyBzcGFjaW5nICsgMiAqIHBhZGRpbmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRDb2x1bW5zTW9kZWwoe1xuICBwYXRoLFxuICBwaG90b3MsXG4gIGNvbnRhaW5lcldpZHRoLFxuICBjb2x1bW5zR2FwcyxcbiAgY29sdW1uc1JhdGlvcyxcbiAgc3BhY2luZyxcbiAgcGFkZGluZ1xufSkge1xuICBjb25zdCBjb2x1bW5zTW9kZWwgPSBbXTtcbiAgY29uc3QgdG90YWxSYXRpbyA9IGNvbHVtbnNSYXRpb3MucmVkdWNlKCh0b3RhbCwgY29sdW1uUmF0aW8pID0+IHRvdGFsICsgY29sdW1uUmF0aW8sIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgY29uc3QgY29sdW1uID0gcGhvdG9zLm1hcCgocGhvdG8sIGluZGV4KSA9PiAoeyBwaG90bywgaW5kZXggfSkpLnNsaWNlKHBhdGhbaV0sIHBhdGhbaSArIDFdKTtcbiAgICBjb25zdCB0b3RhbEFkanVzdGVkR2FwcyA9IGNvbHVtbnNSYXRpb3MucmVkdWNlKFxuICAgICAgKHRvdGFsLCBjb2x1bW5SYXRpbywgaW5kZXgpID0+IHRvdGFsICsgKGNvbHVtbnNHYXBzW2ldIC0gY29sdW1uc0dhcHNbaW5kZXhdKSAqIGNvbHVtblJhdGlvLFxuICAgICAgMFxuICAgICk7XG4gICAgY29uc3QgY29sdW1uV2lkdGggPSAoY29udGFpbmVyV2lkdGggLSAocGF0aC5sZW5ndGggLSAyKSAqIHNwYWNpbmcgLSAyICogKHBhdGgubGVuZ3RoIC0gMSkgKiBwYWRkaW5nIC0gdG90YWxBZGp1c3RlZEdhcHMpICogY29sdW1uc1JhdGlvc1tpXSAvIHRvdGFsUmF0aW87XG4gICAgY29sdW1uc01vZGVsLnB1c2goXG4gICAgICBjb2x1bW4ubWFwKCh7IHBob3RvLCBpbmRleCB9LCBwaG90b0luZGV4KSA9PiAoe1xuICAgICAgICBwaG90byxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgIGhlaWdodDogY29sdW1uV2lkdGggLyByYXRpbyhwaG90byksXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcGhvdG9JbmRleCxcbiAgICAgICAgICBwaG90b3NDb3VudDogY29sdW1uLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIHJldHVybiBjb2x1bW5zTW9kZWw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29sdW1uc01vZGVsKHtcbiAgcGhvdG9zLFxuICBsYXlvdXRPcHRpb25zLFxuICB0YXJnZXRDb2x1bW5XaWR0aFxufSkge1xuICBjb25zdCB7IGNvbHVtbnMsIHNwYWNpbmcsIHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCBjb2x1bW5zR2FwcyA9IFtdO1xuICBjb25zdCBjb2x1bW5zUmF0aW9zID0gW107XG4gIGlmIChwaG90b3MubGVuZ3RoIDw9IGNvbHVtbnMpIHtcbiAgICBjb25zdCBhdmVyYWdlUmF0aW8gPSBwaG90b3MubGVuZ3RoID4gMCA/IHBob3Rvcy5yZWR1Y2UoKGFjYywgcGhvdG8pID0+IGFjYyArIHJhdGlvKHBob3RvKSwgMCkgLyBwaG90b3MubGVuZ3RoIDogMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkgKz0gMSkge1xuICAgICAgY29sdW1uc0dhcHNbaV0gPSAyICogcGFkZGluZztcbiAgICAgIGNvbHVtbnNSYXRpb3NbaV0gPSBpIDwgcGhvdG9zLmxlbmd0aCA/IHJhdGlvKHBob3Rvc1tpXSkgOiBhdmVyYWdlUmF0aW87XG4gICAgfVxuICAgIGNvbnN0IGNvbHVtbnNNb2RlbDIgPSBidWlsZENvbHVtbnNNb2RlbCh7XG4gICAgICBwYXRoOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2x1bW5zICsgMSB9KS5tYXAoKF8sIGluZGV4KSA9PiBNYXRoLm1pbihpbmRleCwgcGhvdG9zLmxlbmd0aCkpLFxuICAgICAgcGhvdG9zLFxuICAgICAgY29sdW1uc1JhdGlvcyxcbiAgICAgIGNvbHVtbnNHYXBzLFxuICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICBzcGFjaW5nLFxuICAgICAgcGFkZGluZ1xuICAgIH0pO1xuICAgIHJldHVybiB7IGNvbHVtbnNHYXBzLCBjb2x1bW5zUmF0aW9zLCBjb2x1bW5zTW9kZWw6IGNvbHVtbnNNb2RlbDIgfTtcbiAgfVxuICBjb25zdCB0YXJnZXRDb2x1bW5IZWlnaHQgPSAocGhvdG9zLnJlZHVjZSgoYWNjLCBwaG90bykgPT4gYWNjICsgdGFyZ2V0Q29sdW1uV2lkdGggLyByYXRpbyhwaG90byksIDApICsgc3BhY2luZyAqIChwaG90b3MubGVuZ3RoIC0gY29sdW1ucykgKyAyICogcGFkZGluZyAqIHBob3Rvcy5sZW5ndGgpIC8gY29sdW1ucztcbiAgY29uc3QgZ2V0TmVpZ2hib3JzID0gbWFrZUdldENvbHVtbk5laWdoYm9ycyh7XG4gICAgcGhvdG9zLFxuICAgIHRhcmdldENvbHVtbldpZHRoLFxuICAgIHRhcmdldENvbHVtbkhlaWdodCxcbiAgICBzcGFjaW5nLFxuICAgIHBhZGRpbmdcbiAgfSk7XG4gIGNvbnN0IHBhdGggPSBmaW5kU2hvcnRlc3RQYXRoTGVuZ3RoTihnZXROZWlnaGJvcnMsIGNvbHVtbnMsIDAsIHBob3Rvcy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgY29uc3QgY29sdW1uID0gcGhvdG9zLnNsaWNlKHBhdGhbaV0sIHBhdGhbaSArIDFdKTtcbiAgICBjb2x1bW5zR2Fwc1tpXSA9IHNwYWNpbmcgKiAoY29sdW1uLmxlbmd0aCAtIDEpICsgMiAqIHBhZGRpbmcgKiBjb2x1bW4ubGVuZ3RoO1xuICAgIGNvbHVtbnNSYXRpb3NbaV0gPSAxIC8gY29sdW1uLnJlZHVjZSgoYWNjLCBwaG90bykgPT4gYWNjICsgMSAvIHJhdGlvKHBob3RvKSwgMCk7XG4gIH1cbiAgY29uc3QgY29sdW1uc01vZGVsID0gYnVpbGRDb2x1bW5zTW9kZWwoe1xuICAgIHBhdGgsXG4gICAgcGhvdG9zLFxuICAgIGNvbHVtbnNSYXRpb3MsXG4gICAgY29sdW1uc0dhcHMsXG4gICAgY29udGFpbmVyV2lkdGgsXG4gICAgc3BhY2luZyxcbiAgICBwYWRkaW5nXG4gIH0pO1xuICByZXR1cm4geyBjb2x1bW5zR2FwcywgY29sdW1uc1JhdGlvcywgY29sdW1uc01vZGVsIH07XG59XG5mdW5jdGlvbiBjb21wdXRlTGF5b3V0KHByb3BzKSB7XG4gIGNvbnN0IHsgcGhvdG9zLCBsYXlvdXRPcHRpb25zIH0gPSBwcm9wcztcbiAgY29uc3QgeyBjb2x1bW5zLCBzcGFjaW5nLCBwYWRkaW5nLCBjb250YWluZXJXaWR0aCB9ID0gbGF5b3V0T3B0aW9ucztcbiAgY29uc3QgdGFyZ2V0Q29sdW1uV2lkdGggPSAoY29udGFpbmVyV2lkdGggLSBzcGFjaW5nICogKGNvbHVtbnMgLSAxKSAtIDIgKiBwYWRkaW5nICogY29sdW1ucykgLyBjb2x1bW5zO1xuICBjb25zdCB7IGNvbHVtbnNHYXBzLCBjb2x1bW5zUmF0aW9zLCBjb2x1bW5zTW9kZWwgfSA9IGNvbXB1dGVDb2x1bW5zTW9kZWwoe1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHRhcmdldENvbHVtbldpZHRoXG4gIH0pO1xuICBpZiAoY29sdW1uc01vZGVsLmZpbmRJbmRleChcbiAgICAoY29sdW1uTW9kZWwpID0+IGNvbHVtbk1vZGVsLmZpbmRJbmRleCgoeyBsYXlvdXQ6IHsgd2lkdGgsIGhlaWdodCB9IH0pID0+IHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSA+PSAwXG4gICkgPj0gMCkge1xuICAgIGlmIChjb2x1bW5zID4gMSkge1xuICAgICAgcmV0dXJuIGNvbXB1dGVMYXlvdXQoeyBwaG90b3MsIGxheW91dE9wdGlvbnM6IHsgLi4ubGF5b3V0T3B0aW9ucywgY29sdW1uczogY29sdW1ucyAtIDEgfSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4geyBjb2x1bW5zTW9kZWwsIGNvbHVtbnNHYXBzLCBjb2x1bW5zUmF0aW9zIH07XG59XG5mdW5jdGlvbiBjb21wdXRlQ29sdW1uc0xheW91dCh7XG4gIHBob3RvcyxcbiAgbGF5b3V0T3B0aW9uc1xufSkge1xuICByZXR1cm4gY29tcHV0ZUxheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDb2x1bW5Db250YWluZXIoe1xuICBjb2x1bW5Db250YWluZXJQcm9wcyxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyAuLi5jb2x1bW5Db250YWluZXJQcm9wcyB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBjc3NDb2x1bW5XaWR0aChwcm9wcykge1xuICBjb25zdCB7IGxheW91dE9wdGlvbnMsIGNvbHVtbkluZGV4LCBjb2x1bW5zQ291bnQsIGNvbHVtbnNHYXBzLCBjb2x1bW5zUmF0aW9zIH0gPSBwcm9wcztcbiAgY29uc3QgeyBsYXlvdXQsIHNwYWNpbmcsIHBhZGRpbmcgfSA9IGxheW91dE9wdGlvbnM7XG4gIGlmIChsYXlvdXQgPT09IFwibWFzb25yeVwiIHx8ICFjb2x1bW5zR2FwcyB8fCAhY29sdW1uc1JhdGlvcykge1xuICAgIHJldHVybiBgY2FsYygoMTAwJSAtICR7c3BhY2luZyAqIChjb2x1bW5zQ291bnQgLSAxKX1weCkgLyAke2NvbHVtbnNDb3VudH0pYDtcbiAgfVxuICBjb25zdCB0b3RhbFJhdGlvID0gY29sdW1uc1JhdGlvcy5yZWR1Y2UoKGFjYywgcmF0aW8yKSA9PiBhY2MgKyByYXRpbzIsIDApO1xuICBjb25zdCB0b3RhbEFkanVzdGVkR2FwcyA9IGNvbHVtbnNSYXRpb3MucmVkdWNlKFxuICAgIChhY2MsIHJhdGlvMiwgaW5kZXgpID0+IGFjYyArIChjb2x1bW5zR2Fwc1tjb2x1bW5JbmRleF0gLSBjb2x1bW5zR2Fwc1tpbmRleF0pICogcmF0aW8yLFxuICAgIDBcbiAgKTtcbiAgcmV0dXJuIGBjYWxjKCgxMDAlIC0gJHtyb3VuZChcbiAgICAoY29sdW1uc0NvdW50IC0gMSkgKiBzcGFjaW5nICsgMiAqIGNvbHVtbnNDb3VudCAqIHBhZGRpbmcgKyB0b3RhbEFkanVzdGVkR2FwcyxcbiAgICAzXG4gICl9cHgpICogJHtyb3VuZChjb2x1bW5zUmF0aW9zW2NvbHVtbkluZGV4XSAvIHRvdGFsUmF0aW8sIDUpfSArICR7MiAqIHBhZGRpbmd9cHgpYDtcbn1cbmZ1bmN0aW9uIENvbHVtbkNvbnRhaW5lclJlbmRlcmVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICBjaGlsZHJlbixcbiAgICBjb2x1bW5Db250YWluZXJQcm9wczogeyBzdHlsZSwgY2xhc3NOYW1lLCAuLi5yZXN0Q29sdW1uQ29udGFpbmVyUHJvcHMgfSA9IHt9LFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuICBjb25zdCBjb2x1bW5Db250YWluZXJQcm9wcyA9IHtcbiAgICBjbGFzc05hbWU6IGNsc3goXCJyZWFjdC1waG90by1hbGJ1bS0tY29sdW1uXCIsIGNsYXNzTmFtZSksXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgIGZsZXhXcmFwOiBcIm5vd3JhcFwiLFxuICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0XCIsXG4gICAgICB3aWR0aDogY3NzQ29sdW1uV2lkdGgocHJvcHMpLFxuICAgICAganVzdGlmeUNvbnRlbnQ6IGxheW91dE9wdGlvbnMubGF5b3V0ID09PSBcImNvbHVtbnNcIiA/IFwic3BhY2UtYmV0d2VlblwiIDogXCJmbGV4LXN0YXJ0XCIsXG4gICAgICAuLi5zdHlsZVxuICAgIH0sXG4gICAgLi4ucmVzdENvbHVtbkNvbnRhaW5lclByb3BzXG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAocmVuZGVyQ29sdW1uQ29udGFpbmVyICE9IG51bGwgPyByZW5kZXJDb2x1bW5Db250YWluZXIgOiBkZWZhdWx0UmVuZGVyQ29sdW1uQ29udGFpbmVyKSh7XG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICBjb2x1bW5Db250YWluZXJQcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICAuLi5yZXN0XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIENvbHVtbnNMYXlvdXQocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJlbmRlclBob3RvLFxuICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICBjb21wb25lbnRzUHJvcHM6IHsgaW1hZ2VQcm9wcywgY29sdW1uQ29udGFpbmVyUHJvcHMgfVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbHVtbnNMYXlvdXQgPSBjb21wdXRlQ29sdW1uc0xheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9KTtcbiAgaWYgKCFjb2x1bW5zTGF5b3V0KVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCB7IGNvbHVtbnNNb2RlbCwgY29sdW1uc1JhdGlvcywgY29sdW1uc0dhcHMgfSA9IGNvbHVtbnNMYXlvdXQ7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb2x1bW5zTW9kZWwubWFwKChjb2x1bW4sIGNvbHVtbkluZGV4KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIENvbHVtbkNvbnRhaW5lclJlbmRlcmVyLFxuICAgIHtcbiAgICAgIGtleTogYGNvbHVtbi0ke2NvbHVtbkluZGV4fWAsXG4gICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgY29sdW1uSW5kZXgsXG4gICAgICBjb2x1bW5zQ291bnQ6IGNvbHVtbnNNb2RlbC5sZW5ndGgsXG4gICAgICBjb2x1bW5zR2FwcyxcbiAgICAgIGNvbHVtbnNSYXRpb3MsXG4gICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICBjb2x1bW5Db250YWluZXJQcm9wc1xuICAgIH0sXG4gICAgY29sdW1uLm1hcCgoeyBwaG90bywgbGF5b3V0IH0pID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBQaG90b1JlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBrZXk6IHBob3RvLmtleSB8fCBwaG90by5zcmMsXG4gICAgICAgIHBob3RvLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIHJlbmRlclBob3RvLFxuICAgICAgICBpbWFnZVByb3BzXG4gICAgICB9XG4gICAgKSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1hc29ucnlMYXlvdXQocHJvcHMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSA9IHByb3BzO1xuICBjb25zdCB7IGNvbHVtbnMsIHNwYWNpbmcsIHBhZGRpbmcsIGNvbnRhaW5lcldpZHRoIH0gPSBsYXlvdXRPcHRpb25zO1xuICBjb25zdCBjb2x1bW5XaWR0aCA9IChjb250YWluZXJXaWR0aCAtIHNwYWNpbmcgKiAoY29sdW1ucyAtIDEpIC0gMiAqIHBhZGRpbmcgKiBjb2x1bW5zKSAvIGNvbHVtbnM7XG4gIGlmIChjb2x1bW5XaWR0aCA8PSAwKSB7XG4gICAgcmV0dXJuIGNvbHVtbnMgPiAxID8gY29tcHV0ZU1hc29ucnlMYXlvdXQoe1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBsYXlvdXRPcHRpb25zOiB7IC4uLmxheW91dE9wdGlvbnMsIGNvbHVtbnM6IGNvbHVtbnMgLSAxIH1cbiAgICB9KSA6IHZvaWQgMDtcbiAgfVxuICBjb25zdCBjb2x1bW5zQ3VycmVudFRvcFBvc2l0aW9ucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkgKz0gMSkge1xuICAgIGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zW2ldID0gMDtcbiAgfVxuICBjb25zdCBjb2x1bW5zTW9kZWwgPSBwaG90b3MucmVkdWNlKFxuICAgIChtb2RlbCwgcGhvdG8sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzaG9ydGVzdENvbHVtbiA9IGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zLnJlZHVjZShcbiAgICAgICAgKGN1cnJlbnRTaG9ydGVzdENvbHVtbiwgaXRlbSwgaSkgPT4gaXRlbSA8IGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zW2N1cnJlbnRTaG9ydGVzdENvbHVtbl0gLSAxID8gaSA6IGN1cnJlbnRTaG9ydGVzdENvbHVtbixcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zW3Nob3J0ZXN0Q29sdW1uXSA9IGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zW3Nob3J0ZXN0Q29sdW1uXSArIGNvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG8pICsgc3BhY2luZyArIDIgKiBwYWRkaW5nO1xuICAgICAgbW9kZWxbc2hvcnRlc3RDb2x1bW5dLnB1c2goeyBwaG90bywgaW5kZXggfSk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcbiAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2x1bW5zIH0pLm1hcCgoKSA9PiBbXSlcbiAgKTtcbiAgcmV0dXJuIGNvbHVtbnNNb2RlbC5tYXAoXG4gICAgKGNvbHVtbikgPT4gY29sdW1uLm1hcCgoeyBwaG90bywgaW5kZXggfSwgcGhvdG9JbmRleCkgPT4gKHtcbiAgICAgIHBob3RvLFxuICAgICAgbGF5b3V0OiB7XG4gICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjb2x1bW5XaWR0aCAvIHJhdGlvKHBob3RvKSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHBob3RvSW5kZXgsXG4gICAgICAgIHBob3Rvc0NvdW50OiBjb2x1bW4ubGVuZ3RoXG4gICAgICB9XG4gICAgfSkpXG4gICk7XG59XG5mdW5jdGlvbiBNYXNvbnJ5TGF5b3V0KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBwaG90b3MsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICByZW5kZXJQaG90byxcbiAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgY29tcG9uZW50c1Byb3BzOiB7IGltYWdlUHJvcHMsIGNvbHVtbkNvbnRhaW5lclByb3BzIH1cbiAgfSA9IHByb3BzO1xuICBjb25zdCBtYXNvbnJ5TGF5b3V0ID0gY29tcHV0ZU1hc29ucnlMYXlvdXQoeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSk7XG4gIGlmICghbWFzb25yeUxheW91dClcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIG1hc29ucnlMYXlvdXQubWFwKChjb2x1bW4sIGNvbHVtbkluZGV4KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIENvbHVtbkNvbnRhaW5lclJlbmRlcmVyLFxuICAgIHtcbiAgICAgIGtleTogYG1hc29ucnktY29sdW1uLSR7Y29sdW1uSW5kZXh9YCxcbiAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICBjb2x1bW5zQ291bnQ6IG1hc29ucnlMYXlvdXQubGVuZ3RoLFxuICAgICAgY29sdW1uSW5kZXgsXG4gICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICBjb2x1bW5Db250YWluZXJQcm9wc1xuICAgIH0sXG4gICAgY29sdW1uLm1hcCgoeyBwaG90bywgbGF5b3V0IH0pID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBQaG90b1JlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBrZXk6IHBob3RvLmtleSB8fCBwaG90by5zcmMsXG4gICAgICAgIHBob3RvLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIHJlbmRlclBob3RvLFxuICAgICAgICBpbWFnZVByb3BzXG4gICAgICB9XG4gICAgKSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNvbnRhaW5lcih7IGNvbnRhaW5lclByb3BzLCBjaGlsZHJlbiwgY29udGFpbmVyUmVmIH0pIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGNvbnRhaW5lclJlZiwgLi4uY29udGFpbmVyUHJvcHMgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gQ29udGFpbmVyUmVuZGVyZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGxheW91dCxcbiAgICByZW5kZXJDb250YWluZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGFpbmVyUmVmLFxuICAgIGNvbnRhaW5lclByb3BzOiB7IHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3RDb250YWluZXJQcm9wcyB9ID0ge31cbiAgfSA9IHByb3BzO1xuICBjb25zdCBjb250YWluZXJQcm9wcyA9IHtcbiAgICBjbGFzc05hbWU6IGNsc3goXCJyZWFjdC1waG90by1hbGJ1bVwiLCBgcmVhY3QtcGhvdG8tYWxidW0tLSR7bGF5b3V0fWAsIGNsYXNzTmFtZSksXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBsYXlvdXQgPT09IFwicm93c1wiID8gXCJjb2x1bW5cIiA6IFwicm93XCIsXG4gICAgICAuLi5zdHlsZVxuICAgIH0sXG4gICAgLi4ucmVzdENvbnRhaW5lclByb3BzXG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAocmVuZGVyQ29udGFpbmVyICE9IG51bGwgPyByZW5kZXJDb250YWluZXIgOiBkZWZhdWx0UmVuZGVyQ29udGFpbmVyKSh7XG4gICAgY29udGFpbmVyUHJvcHMsXG4gICAgY29udGFpbmVyUmVmLFxuICAgIGxheW91dCxcbiAgICBjaGlsZHJlblxuICB9KSk7XG59XG5mdW5jdGlvbiB1c2VBcnJheShhcnJheSkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoYXJyYXkpO1xuICBpZiAoIWFycmF5IHx8ICFyZWYuY3VycmVudCB8fCBhcnJheS5qb2luKCkgIT09IHJlZi5jdXJyZW50LmpvaW4oKSkge1xuICAgIHJlZi5jdXJyZW50ID0gYXJyYXk7XG4gIH1cbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuZnVuY3Rpb24gY29udGFpbmVyV2lkdGhSZWR1Y2VyKHN0YXRlLCB7IG5ld0NvbnRhaW5lcldpZHRoLCBuZXdTY3JvbGxiYXJXaWR0aCB9KSB7XG4gIGNvbnN0IHsgY29udGFpbmVyV2lkdGgsIHNjcm9sbGJhcldpZHRoIH0gPSBzdGF0ZTtcbiAgaWYgKGNvbnRhaW5lcldpZHRoICE9PSB2b2lkIDAgJiYgc2Nyb2xsYmFyV2lkdGggIT09IHZvaWQgMCAmJiBuZXdDb250YWluZXJXaWR0aCAhPT0gdm9pZCAwICYmIG5ld1Njcm9sbGJhcldpZHRoICE9PSB2b2lkIDAgJiYgbmV3Q29udGFpbmVyV2lkdGggPiBjb250YWluZXJXaWR0aCAmJiBuZXdDb250YWluZXJXaWR0aCAtIGNvbnRhaW5lcldpZHRoIDw9IDIwICYmIG5ld1Njcm9sbGJhcldpZHRoIDwgc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICByZXR1cm4geyBjb250YWluZXJXaWR0aCwgc2Nyb2xsYmFyV2lkdGg6IG5ld1Njcm9sbGJhcldpZHRoIH07XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcldpZHRoICE9PSBuZXdDb250YWluZXJXaWR0aCB8fCBzY3JvbGxiYXJXaWR0aCAhPT0gbmV3U2Nyb2xsYmFyV2lkdGggPyB7IGNvbnRhaW5lcldpZHRoOiBuZXdDb250YWluZXJXaWR0aCwgc2Nyb2xsYmFyV2lkdGg6IG5ld1Njcm9sbGJhcldpZHRoIH0gOiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDb250YWluZXJXaWR0aChlbCwgYnJlYWtwb2ludHMyKSB7XG4gIGxldCB3aWR0aCA9IGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5jbGllbnRXaWR0aDtcbiAgaWYgKHdpZHRoICE9PSB2b2lkIDAgJiYgYnJlYWtwb2ludHMyICYmIGJyZWFrcG9pbnRzMi5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc29ydGVkID0gWy4uLmJyZWFrcG9pbnRzMi5maWx0ZXIoKHgpID0+IHggPiAwKV0uc29ydCgoYSwgYikgPT4gYiAtIGEpO1xuICAgIHNvcnRlZC5wdXNoKE1hdGguZmxvb3Ioc29ydGVkW3NvcnRlZC5sZW5ndGggLSAxXSAvIDIpKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB3aWR0aDtcbiAgICB3aWR0aCA9IHNvcnRlZC5maW5kKChicmVha3BvaW50LCBpbmRleCkgPT4gYnJlYWtwb2ludCA8PSB0aHJlc2hvbGQgfHwgaW5kZXggPT09IHNvcnRlZC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiB1c2VDb250YWluZXJXaWR0aChicmVha3BvaW50czIsIGRlZmF1bHRDb250YWluZXJXaWR0aCkge1xuICBjb25zdCBbeyBjb250YWluZXJXaWR0aCB9LCBkaXNwYXRjaF0gPSBSZWFjdC51c2VSZWR1Y2VyKGNvbnRhaW5lcldpZHRoUmVkdWNlciwge1xuICAgIGNvbnRhaW5lcldpZHRoOiBkZWZhdWx0Q29udGFpbmVyV2lkdGhcbiAgfSk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb2JzZXJ2ZXJSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKG5vZGUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IG9ic2VydmVyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICBvYnNlcnZlclJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgY29uc3QgdXBkYXRlV2lkdGggPSAoKSA9PiBkaXNwYXRjaCh7XG4gICAgICAgIG5ld0NvbnRhaW5lcldpZHRoOiByZXNvbHZlQ29udGFpbmVyV2lkdGgocmVmLmN1cnJlbnQsIGJyZWFrcG9pbnRzMiksXG4gICAgICAgIG5ld1Njcm9sbGJhcldpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuICAgICAgfSk7XG4gICAgICB1cGRhdGVXaWR0aCgpO1xuICAgICAgaWYgKG5vZGUgJiYgdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIodXBkYXRlV2lkdGgpO1xuICAgICAgICBvYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUobm9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbYnJlYWtwb2ludHMyXVxuICApO1xuICByZXR1cm4geyBjb250YWluZXJSZWYsIGNvbnRhaW5lcldpZHRoIH07XG59XG5jb25zdCBicmVha3BvaW50cyA9IE9iamVjdC5mcmVlemUoWzEyMDAsIDYwMCwgMzAwLCAwXSk7XG5mdW5jdGlvbiB1bndyYXAodmFsdWUsIGFyZykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZShhcmcpIDogdmFsdWU7XG59XG5mdW5jdGlvbiB1bndyYXBQYXJhbWV0ZXIodmFsdWUsIGNvbnRhaW5lcldpZHRoKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIgPyB1bndyYXAodmFsdWUsIGNvbnRhaW5lcldpZHRoKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNlbGVjdFJlc3BvbnNpdmVWYWx1ZSh2YWx1ZXMsIGNvbnRhaW5lcldpZHRoKSB7XG4gIGNvbnN0IGluZGV4ID0gYnJlYWtwb2ludHMuZmluZEluZGV4KChicmVha3BvaW50KSA9PiBicmVha3BvaW50IDw9IGNvbnRhaW5lcldpZHRoKTtcbiAgcmV0dXJuIHVud3JhcCh2YWx1ZXNbaW5kZXggPj0gMCA/IGluZGV4IDogMF0sIGNvbnRhaW5lcldpZHRoKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZXNwb25zaXZlUGFyYW1ldGVyKHBhcmFtZXRlciwgY29udGFpbmVyV2lkdGgsIHZhbHVlcywgbWluVmFsdWUgPSAwKSB7XG4gIGNvbnN0IHZhbHVlID0gdW53cmFwUGFyYW1ldGVyKHBhcmFtZXRlciwgY29udGFpbmVyV2lkdGgpO1xuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1heCh2YWx1ZSA9PT0gdm9pZCAwID8gc2VsZWN0UmVzcG9uc2l2ZVZhbHVlKHZhbHVlcywgY29udGFpbmVyV2lkdGgpIDogdmFsdWUsIG1pblZhbHVlKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF5b3V0T3B0aW9ucyh7XG4gIGxheW91dCxcbiAgb25DbGljayxcbiAgY29udGFpbmVyV2lkdGgsXG4gIHRhcmdldFJvd0hlaWdodCxcbiAgcm93Q29uc3RyYWludHMsXG4gIGNvbHVtbnMsXG4gIHNwYWNpbmcsXG4gIHBhZGRpbmcsXG4gIHNpemVzXG59KSB7XG4gIHJldHVybiB7XG4gICAgbGF5b3V0LFxuICAgIG9uQ2xpY2ssXG4gICAgY29udGFpbmVyV2lkdGgsXG4gICAgY29sdW1uczogcmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIoY29sdW1ucywgY29udGFpbmVyV2lkdGgsIFs1LCA0LCAzLCAyXSwgMSksXG4gICAgc3BhY2luZzogcmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIoc3BhY2luZywgY29udGFpbmVyV2lkdGgsIFsyMCwgMTUsIDEwLCA1XSksXG4gICAgcGFkZGluZzogcmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIocGFkZGluZywgY29udGFpbmVyV2lkdGgsIFswLCAwLCAwLCAwLCAwXSksXG4gICAgdGFyZ2V0Um93SGVpZ2h0OiByZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlcih0YXJnZXRSb3dIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCBbXG4gICAgICAodykgPT4gdyAvIDUsXG4gICAgICAodykgPT4gdyAvIDQsXG4gICAgICAodykgPT4gdyAvIDMsXG4gICAgICAodykgPT4gdyAvIDJcbiAgICBdKSxcbiAgICByb3dDb25zdHJhaW50czogdW53cmFwUGFyYW1ldGVyKHJvd0NvbnN0cmFpbnRzLCBjb250YWluZXJXaWR0aCksXG4gICAgc2l6ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzUHJvcHMocHJvcHMsIGNvbnRhaW5lcldpZHRoLCBsYXlvdXRPcHRpb25zKSB7XG4gIGNvbnN0IHsgcGhvdG9zLCBjb21wb25lbnRzUHJvcHM6IGNvbXBvbmVudHNQcm9wc1Byb3AgfSA9IHByb3BzO1xuICBjb25zdCBjb21wb25lbnRzUHJvcHMgPSB1bndyYXAoY29tcG9uZW50c1Byb3BzUHJvcCwgY29udGFpbmVyV2lkdGgpIHx8IHt9O1xuICBpZiAobGF5b3V0T3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5b3V0LCBzcGFjaW5nLCBwYWRkaW5nLCByb3dDb25zdHJhaW50cyB9ID0gbGF5b3V0T3B0aW9ucztcbiAgICBpZiAobGF5b3V0ID09PSBcInJvd3NcIikge1xuICAgICAgY29uc3QgeyBzaW5nbGVSb3dNYXhIZWlnaHQgfSA9IHJvd0NvbnN0cmFpbnRzIHx8IHt9O1xuICAgICAgaWYgKHNpbmdsZVJvd01heEhlaWdodCkge1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgcGhvdG9zLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIHsgd2lkdGgsIGhlaWdodCB9KSA9PiBhY2MgKyB3aWR0aCAvIGhlaWdodCAqIHNpbmdsZVJvd01heEhlaWdodCAtIDIgKiBwYWRkaW5nLFxuICAgICAgICAgICAgcGFkZGluZyAqIHBob3Rvcy5sZW5ndGggKiAyICsgc3BhY2luZyAqIChwaG90b3MubGVuZ3RoIC0gMSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXhXaWR0aCA+IDApIHtcbiAgICAgICAgICBjb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHMgPSBjb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHMgfHwge307XG4gICAgICAgICAgY29tcG9uZW50c1Byb3BzLmNvbnRhaW5lclByb3BzLnN0eWxlID0geyBtYXhXaWR0aCwgLi4uY29tcG9uZW50c1Byb3BzLmNvbnRhaW5lclByb3BzLnN0eWxlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNQcm9wcztcbn1cbmZ1bmN0aW9uIHJlbmRlckxheW91dChwcm9wcywgY29tcG9uZW50c1Byb3BzLCBsYXlvdXRPcHRpb25zKSB7XG4gIGNvbnN0IHsgcGhvdG9zLCBsYXlvdXQsIHJlbmRlclBob3RvLCByZW5kZXJSb3dDb250YWluZXIsIHJlbmRlckNvbHVtbkNvbnRhaW5lciB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbW1vbkxheW91dFByb3BzID0geyBwaG90b3MsIHJlbmRlclBob3RvLCBjb21wb25lbnRzUHJvcHMgfTtcbiAgaWYgKGxheW91dCA9PT0gXCJyb3dzXCIpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFJvd3NMYXlvdXQsXG4gICAgICB7XG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIHJlbmRlclJvd0NvbnRhaW5lcixcbiAgICAgICAgLi4uY29tbW9uTGF5b3V0UHJvcHNcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGlmIChsYXlvdXQgPT09IFwiY29sdW1uc1wiKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDb2x1bW5zTGF5b3V0LFxuICAgICAge1xuICAgICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICAgIC4uLmNvbW1vbkxheW91dFByb3BzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBNYXNvbnJ5TGF5b3V0LFxuICAgIHtcbiAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICAuLi5jb21tb25MYXlvdXRQcm9wc1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIFBob3RvQWxidW0ocHJvcHMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGxheW91dCwgcmVuZGVyQ29udGFpbmVyLCBkZWZhdWx0Q29udGFpbmVyV2lkdGgsIGJyZWFrcG9pbnRzOiBicmVha3BvaW50czIgfSA9IHByb3BzO1xuICBjb25zdCB7IGNvbnRhaW5lclJlZiwgY29udGFpbmVyV2lkdGggfSA9IHVzZUNvbnRhaW5lcldpZHRoKHVzZUFycmF5KGJyZWFrcG9pbnRzMiksIGRlZmF1bHRDb250YWluZXJXaWR0aCk7XG4gIGlmICghbGF5b3V0IHx8ICFbXCJyb3dzXCIsIFwiY29sdW1uc1wiLCBcIm1hc29ucnlcIl0uaW5jbHVkZXMobGF5b3V0KSB8fCAhQXJyYXkuaXNBcnJheShwaG90b3MpKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBsYXlvdXRPcHRpb25zID0gY29udGFpbmVyV2lkdGggPyByZXNvbHZlTGF5b3V0T3B0aW9ucyh7IGNvbnRhaW5lcldpZHRoLCAuLi5wcm9wcyB9KSA6IHZvaWQgMDtcbiAgY29uc3QgY29tcG9uZW50c1Byb3BzID0gcmVzb2x2ZUNvbXBvbmVudHNQcm9wcyhwcm9wcywgY29udGFpbmVyV2lkdGgsIGxheW91dE9wdGlvbnMpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBDb250YWluZXJSZW5kZXJlcixcbiAgICB7XG4gICAgICBsYXlvdXQsXG4gICAgICBjb250YWluZXJSZWYsXG4gICAgICByZW5kZXJDb250YWluZXIsXG4gICAgICBjb250YWluZXJQcm9wczogY29tcG9uZW50c1Byb3BzLmNvbnRhaW5lclByb3BzXG4gICAgfSxcbiAgICBsYXlvdXRPcHRpb25zICYmIHJlbmRlckxheW91dChwcm9wcywgY29tcG9uZW50c1Byb3BzLCBsYXlvdXRPcHRpb25zKVxuICApO1xufVxuZXhwb3J0IHtcbiAgUGhvdG9BbGJ1bSxcbiAgUGhvdG9BbGJ1bSBhcyBkZWZhdWx0LFxuICBjb21wdXRlQ29sdW1uc0xheW91dCBhcyB1bnN0YWJsZV9jb21wdXRlQ29sdW1uc0xheW91dCxcbiAgY29tcHV0ZU1hc29ucnlMYXlvdXQgYXMgdW5zdGFibGVfY29tcHV0ZU1hc29ucnlMYXlvdXQsXG4gIGNvbXB1dGVSb3dzTGF5b3V0IGFzIHVuc3RhYmxlX2NvbXB1dGVSb3dzTGF5b3V0XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwicmF0aW8iLCJ3aWR0aCIsImhlaWdodCIsInJvdW5kIiwidmFsdWUiLCJkZWNpbWFscyIsImZhY3RvciIsIk1hdGgiLCJOdW1iZXIiLCJFUFNJTE9OIiwicmFua2luZ0Z1bmN0aW9uQ29tcGFyYXRvciIsInJhbmsiLCJhIiwiYiIsIk1pbkhlYXAiLCJncmVhdGVyIiwiaSIsImoiLCJjb21wYXJhdG9yIiwiaGVhcCIsInN3YXAiLCJ0ZW1wIiwic3dpbSIsImsiLCJrMiIsImZsb29yIiwic2luayIsIm4iLCJwdXNoIiwiZWxlbWVudCIsInBvcCIsIm1heCIsInNpemUiLCJjb25zdHJ1Y3RvciIsImJ1aWxkUHJlY2VkZW50c01hcCIsImdyYXBoIiwic3RhcnROb2RlIiwiZW5kTm9kZSIsInByZWNlZGVudHNNYXAiLCJNYXAiLCJ2aXNpdGVkIiwiU2V0Iiwic3RvcmVkU2hvcnRlc3RQYXRocyIsInNldCIsInF1ZXVlIiwiZWwiLCJ3ZWlnaHQiLCJpZCIsImhhcyIsIm5laWdoYm9yaW5nTm9kZXMiLCJhZGQiLCJmb3JFYWNoIiwibmVpZ2hib3JXZWlnaHQiLCJuZWlnaGJvciIsIm5ld1dlaWdodCIsImN1cnJlbnRJZCIsImdldCIsImN1cnJlbnRXZWlnaHQiLCJnZXRQYXRoRnJvbVByZWNlZGVudHNNYXAiLCJub2RlcyIsIm5vZGUiLCJyZXZlcnNlIiwiZmluZFNob3J0ZXN0UGF0aCIsImZpbmRJZGVhbE5vZGVTZWFyY2giLCJwaG90b3MiLCJ0YXJnZXRSb3dIZWlnaHQiLCJjb250YWluZXJXaWR0aCIsIm1pblJhdGlvIiwicmVkdWNlIiwiYWNjIiwicGhvdG8iLCJtaW4iLCJNQVhfVkFMVUUiLCJnZXRDb21tb25IZWlnaHQiLCJyb3ciLCJzcGFjaW5nIiwicGFkZGluZyIsInJvd1dpZHRoIiwibGVuZ3RoIiwidG90YWxBc3BlY3RSYXRpbyIsImNvc3QiLCJzbGljZSIsImNvbW1vbkhlaWdodCIsIm1ha2VHZXRSb3dOZWlnaGJvcnMiLCJsYXlvdXRPcHRpb25zIiwibGltaXROb2RlU2VhcmNoIiwicm93Q29uc3RyYWludHMiLCJfYSIsIl9iIiwicmVzdWx0cyIsInN0YXJ0T2Zmc2V0IiwibWluUGhvdG9zIiwiZW5kT2Zmc2V0IiwibWF4UGhvdG9zIiwiSW5maW5pdHkiLCJjdXJyZW50Q29zdCIsImNvbXB1dGVSb3dzTGF5b3V0IiwiZ2V0TmVpZ2hib3JzIiwicGF0aCIsImxheW91dCIsIm1hcCIsImluZGV4IiwicGhvdG9JbmRleCIsInBob3Rvc0NvdW50IiwiY2xzeCIsImNsYXNzZXMiLCJmaWx0ZXIiLCJjbHMiLCJCb29sZWFuIiwiam9pbiIsImNhbGNXaWR0aCIsImJhc2UiLCJnYXBzIiwiY3NzUGhvdG9XaWR0aCIsImNhbGN1bGF0ZVNpemVzVmFsdWUiLCJtYXRjaCIsInNyY1NldEFuZFNpemVzIiwic3JjU2V0Iiwic2l6ZXMiLCJpbWFnZXMiLCJjb25jYXQiLCJmaW5kIiwic3JjIiwic29ydCIsImZpcnN0Iiwic2Vjb25kIiwiaW1hZ2UiLCJ2aWV3cG9ydCIsImNlaWwiLCJQaG90b1JlbmRlcmVyIiwicHJvcHMiLCJpbWFnZVByb3BzIiwic3R5bGUiLCJjbGFzc05hbWUiLCJyZXN0SW1hZ2VQcm9wcyIsInJlbmRlclBob3RvIiwib25DbGljayIsImltYWdlU3R5bGUiLCJkaXNwbGF5IiwiYm94U2l6aW5nIiwiYXNwZWN0UmF0aW8iLCJtYXJnaW5Cb3R0b20iLCJjdXJzb3IiLCJoYW5kbGVDbGljayIsImV2ZW50IiwiYWx0IiwidGl0bGUiLCJsb2FkaW5nIiwiZGVjb2RpbmciLCJyZW5kZXJEZWZhdWx0UGhvdG8iLCJvcHRpb25zIiwidW53cmFwcGVkU3R5bGUiLCJyZXN0IiwiY3JlYXRlRWxlbWVudCIsIndyYXBwZWQiLCJ3cmFwcGVyU3R5bGUiLCJGcmFnbWVudCIsImRlZmF1bHRSZW5kZXJSb3dDb250YWluZXIiLCJyb3dDb250YWluZXJQcm9wcyIsImNoaWxkcmVuIiwiUm93Q29udGFpbmVyUmVuZGVyZXIiLCJyb3dJbmRleCIsInJvd3NDb3VudCIsInJlbmRlclJvd0NvbnRhaW5lciIsInJlc3RSb3dDb250YWluZXJQcm9wcyIsImZsZXhEaXJlY3Rpb24iLCJmbGV4V3JhcCIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsIlJvd3NMYXlvdXQiLCJjb21wb25lbnRzUHJvcHMiLCJyb3dzTGF5b3V0Iiwia2V5IiwiY29tcHV0ZVNob3J0ZXN0UGF0aCIsInBhdGhMZW5ndGgiLCJtYXRyaXgiLCJjdXJyZW50UXVldWUiLCJrZXlzIiwiY2xlYXIiLCJhY2N1bXVsYXRlZFdlaWdodCIsInBhdGhzIiwibmV4dFBhdGgiLCJyZWNvbnN0cnVjdFNob3J0ZXN0UGF0aCIsImZpbmRTaG9ydGVzdFBhdGhMZW5ndGhOIiwibWFrZUdldENvbHVtbk5laWdoYm9ycyIsInRhcmdldENvbHVtbldpZHRoIiwidGFyZ2V0Q29sdW1uSGVpZ2h0IiwiY3V0T2ZmSGVpZ2h0IiwiYnVpbGRDb2x1bW5zTW9kZWwiLCJjb2x1bW5zR2FwcyIsImNvbHVtbnNSYXRpb3MiLCJjb2x1bW5zTW9kZWwiLCJ0b3RhbFJhdGlvIiwidG90YWwiLCJjb2x1bW5SYXRpbyIsImNvbHVtbiIsInRvdGFsQWRqdXN0ZWRHYXBzIiwiY29sdW1uV2lkdGgiLCJjb21wdXRlQ29sdW1uc01vZGVsIiwiY29sdW1ucyIsImF2ZXJhZ2VSYXRpbyIsImNvbHVtbnNNb2RlbDIiLCJBcnJheSIsImZyb20iLCJfIiwiY29tcHV0ZUxheW91dCIsImZpbmRJbmRleCIsImNvbHVtbk1vZGVsIiwiY29tcHV0ZUNvbHVtbnNMYXlvdXQiLCJkZWZhdWx0UmVuZGVyQ29sdW1uQ29udGFpbmVyIiwiY29sdW1uQ29udGFpbmVyUHJvcHMiLCJjc3NDb2x1bW5XaWR0aCIsImNvbHVtbkluZGV4IiwiY29sdW1uc0NvdW50IiwicmF0aW8yIiwiQ29sdW1uQ29udGFpbmVyUmVuZGVyZXIiLCJyZW5kZXJDb2x1bW5Db250YWluZXIiLCJyZXN0Q29sdW1uQ29udGFpbmVyUHJvcHMiLCJDb2x1bW5zTGF5b3V0IiwiY29sdW1uc0xheW91dCIsImNvbXB1dGVNYXNvbnJ5TGF5b3V0IiwiY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnMiLCJtb2RlbCIsInNob3J0ZXN0Q29sdW1uIiwiY3VycmVudFNob3J0ZXN0Q29sdW1uIiwiaXRlbSIsIk1hc29ucnlMYXlvdXQiLCJtYXNvbnJ5TGF5b3V0IiwiZGVmYXVsdFJlbmRlckNvbnRhaW5lciIsImNvbnRhaW5lclByb3BzIiwiY29udGFpbmVyUmVmIiwicmVmIiwiQ29udGFpbmVyUmVuZGVyZXIiLCJyZW5kZXJDb250YWluZXIiLCJyZXN0Q29udGFpbmVyUHJvcHMiLCJ1c2VBcnJheSIsImFycmF5IiwidXNlUmVmIiwiY3VycmVudCIsImNvbnRhaW5lcldpZHRoUmVkdWNlciIsInN0YXRlIiwibmV3Q29udGFpbmVyV2lkdGgiLCJuZXdTY3JvbGxiYXJXaWR0aCIsInNjcm9sbGJhcldpZHRoIiwicmVzb2x2ZUNvbnRhaW5lcldpZHRoIiwiYnJlYWtwb2ludHMyIiwiY2xpZW50V2lkdGgiLCJzb3J0ZWQiLCJ4IiwidGhyZXNob2xkIiwiYnJlYWtwb2ludCIsInVzZUNvbnRhaW5lcldpZHRoIiwiZGVmYXVsdENvbnRhaW5lcldpZHRoIiwiZGlzcGF0Y2giLCJ1c2VSZWR1Y2VyIiwib2JzZXJ2ZXJSZWYiLCJ1c2VDYWxsYmFjayIsImRpc2Nvbm5lY3QiLCJ1cGRhdGVXaWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImJyZWFrcG9pbnRzIiwiT2JqZWN0IiwiZnJlZXplIiwidW53cmFwIiwiYXJnIiwidW53cmFwUGFyYW1ldGVyIiwic2VsZWN0UmVzcG9uc2l2ZVZhbHVlIiwidmFsdWVzIiwicmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIiLCJwYXJhbWV0ZXIiLCJtaW5WYWx1ZSIsInJlc29sdmVMYXlvdXRPcHRpb25zIiwidyIsInJlc29sdmVDb21wb25lbnRzUHJvcHMiLCJjb21wb25lbnRzUHJvcHNQcm9wIiwic2luZ2xlUm93TWF4SGVpZ2h0IiwibWF4V2lkdGgiLCJyZW5kZXJMYXlvdXQiLCJjb21tb25MYXlvdXRQcm9wcyIsIlBob3RvQWxidW0iLCJpbmNsdWRlcyIsImlzQXJyYXkiLCJkZWZhdWx0IiwidW5zdGFibGVfY29tcHV0ZUNvbHVtbnNMYXlvdXQiLCJ1bnN0YWJsZV9jb21wdXRlTWFzb25yeUxheW91dCIsInVuc3RhYmxlX2NvbXB1dGVSb3dzTGF5b3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-photo-album/dist/index.mjs\n"));

/***/ })

});